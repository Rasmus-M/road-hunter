*********************************************************************
*
* Road Hunter
*
* For the TI-99/4A home computer.
*
* (c) Rasmus Moustgaard 2014 <rasmus.moustgaard@gmail.com>
*
*********************************************************************

	  DEF	START,SFIRST,SLAST,SLOAD

**
* Configuration
*
FINLVS EQU	1					* Finite lives (0 for infinite)
FINFUL EQU	1	  				* Finite fuel (0 for infinite)
FINFIR EQU	1					* Finite fire  0 for infinite)
CCRASH EQU	1					* Car can crash (0 for invincibility)
CHITS  EQU  1					* Car can hit other cars (0 to turn off)
NLIVES EQU	5					* Number of lives
XLFSCO EQU  3					* Thousands of points between extra lives
SLEVEL EQU	0					* Starting level
FLICKR EQU	1					* Use sprite flicker routine
CART   EQU	1					* Assemble cartridge version
	  
**
* Constants
*
MAPW   EQU	24					* Map width in characters
MAPH   EQU	24*104				* Map height in characters
STARTX EQU	72					* Start x position of car
STARTY EQU	128					* Start y position of car
MAXSPD EQU	64					* Maximum car speed
CHZERO EQU	192					* Index of 0 character
SPROFS EQU	32					* Offset between sprite color layers
NSPRTS EQU	20					* Number of sprites
NSPRPS EQU	35					* Number of sprite patterns
NCARS  EQU	7					* Number of other cars
NMAPS  EQU	3					* Number of maps

**
* Misc memory addresses
VDPRD  EQU  >8800				* VDP read data
VDPSTA EQU  >8802				* VDP status
VDPWD  EQU  >8C00				* VDP write data
VDPWA  EQU  >8C02				* VDP set read/write address
RNDSD  EQU	>83C0				* Random number seed
SOUND  EQU	>8400				* Sound

* VDP Memory Map
PTRNT0 EQU	>0000				* Pattern generator table base 0
PTRNT1 EQU	>0800				* Pattern generator table base 1
PTRNT2 EQU	>1000				* Pattern generator table base 2
PTRNT3 EQU	>1800				* Pattern generator table base 3
NAMET0 EQU	>2000				* Name table base 0
COLRTB EQU	>2300				* Color table base
NAMET1 EQU	>2400				* Name table base 1
SPRAT0 EQU	>2700				* Sprite attribute table 0
SPRAT1 EQU	>2780				* Sprite attribute table 1
SPRPTB EQU	>2800				* Sprite pattern table
*								* >3000 - >3600 available
PAB	   EQU	>3600				* Location of PAB
PABBUF EQU	>3680				* Buffer for file reads
FILBUF EQU	>37D8				* DSR file buffers (don't erase!)

**
* Workspace
WRKSP  EQU  >8300				* Workspace
R0LB   EQU  WRKSP+1				* R0 low byte reqd for VDP routines
R1LB   EQU  WRKSP+3
R2LB   EQU  WRKSP+5
R3LB   EQU  WRKSP+7

**
* General Workspace Use:
*
* R10 Stack pointer
* R11 Return address

**
* Scratch pad RAM use - Variables
*
PAD	   EQU  >8300				* Workspace
*			>831F				* Bottom of workspace
STACK  EQU  PAD+32				* Subroutine stack, grows down (8 words)
VM8BW  EQU	STACK+16			* Copy routine (22 bytes)
ONE	   EQU	VM8BW+22			* Constant 1
SPROFF EQU	ONE+2				* Constant >C000
COINC  EQU	SPROFF+2			* Coincidence flag
TICK   EQU	COINC+2				* Vsync counter
RANDNO EQU	TICK+2				* Random number
SCRLY  EQU	RANDNO+2			* Scroll offset (pixels)
SCRLSP EQU	SCRLY+2				* Scroll speed (pixels)
DELAY  EQU	SCRLSP+2			* Number of vsyncs to wait 
DELAYT EQU	DELAY+2				* Temporary delay
SCRPTR EQU	DELAYT+2			* Screen list pointer
ROWPOS EQU	SCRPTR+2			* Screen row position
RDXPTR EQU	ROWPOS+2			* Road direction list pointer
ROADX  EQU	RDXPTR+2			* Road x position in pixels
ROADW  EQU	ROADX+2				* Road width in pixels - 16
PGICNT EQU	ROADW+2				* Progress indicator update count down
SPEED  EQU	PGICNT+2			* Car speed (0 - 63)
DX	   EQU	SPEED+2				* Car movement direction (-1, 0, 1)
FUEL   EQU	DX+2				* Fuel (0 - 63)
STATUS EQU	FUEL+2				* Player/car status (see below)
LIVES  EQU	STATUS+2			* Lives left
XLFCNT EQU	LIVES+2				* Extra life counter
LEVEL  EQU	XLFCNT+2			* Current level number (zero based)
LVLDAT EQU  LEVEL+2				* Current level data address
CARPTH EQU	LVLDAT+2			* Car path pointer
CAR1Y  EQU	CARPTH+2			* Car 1 y position (map coordinates)
CAR2Y  EQU	CAR1Y+2				* Car 2 y position (map coordinates)
CAR3Y  EQU	CAR2Y+2				* Car 3 y position (map coordinates)
CAR4Y  EQU	CAR3Y+2				* Car 4 y position (map coordinates)
CAR5Y  EQU	CAR4Y+2				* Car 5 y position (map coordinates)
CAR6Y  EQU	CAR5Y+2				* Car 6 y position (map coordinates)
CAR7Y  EQU	CAR6Y+2				* Car 7 y position (map coordinates)
CAR1DY EQU	CAR7Y+2				* Car 1 y speed (-1 = exploded)
CAR2DY EQU	CAR1DY+2			* Car 2 y speed (-1 = exploded)
CAR3DY EQU	CAR2DY+2			* Car 3 y speed (-1 = exploded)
CAR4DY EQU	CAR3DY+2			* Car 4 y speed (-1 = exploded)
CAR5DY EQU	CAR4DY+2			* Car 5 y speed (-1 = exploded)
CAR6DY EQU	CAR5DY+2			* Car 6 y speed (-1 = exploded)
CAR7DY EQU	CAR6DY+2			* Car 7 y speed (-1 = exploded)
CAR1PT EQU	CAR7DY+2			* Car 1 path pointer
CAR2PT EQU	CAR1PT+2			* Car 2 path pointer
CAR3PT EQU	CAR2PT+2			* Car 3 path pointer
CAR4PT EQU	CAR3PT+2			* Car 4 path pointer
CAR5PT EQU	CAR4PT+2			* Car 5 path pointer
CAR6PT EQU	CAR5PT+2			* Car 6 path pointer
CAR7PT EQU	CAR6PT+2			* Car 7 path pointer
CARCOL EQU	CAR7PT+2			* Color of generated car
NSHOTS EQU	CARCOL+2			* Number of shots left
SNDAD0 EQU	NSHOTS+2			* Sound player data address channel 0
SNDAD1 EQU	SNDAD0+2			* Sound player data address channel 1
SNDAD2 EQU	SNDAD1+2			* Sound player data address channel 2
SNDAD3 EQU	SNDAD2+2			* Sound player data address channel 3
SNDAD4 EQU	SNDAD3+2			* Sound player data address channel 4
SPRTBL EQU	SNDAD4+2			* Current sprite attribute table toggle (0, -1)
SPRATT EQU	SPRTBL+2			* Sprite attributes
PADMAX EQU	NSPRTS*4+SPRATT

* Status
OK	   EQU	0
COMPLT EQU	1					* Level completed
NOFUEL EQU	2					* Out of fuel
NOCARS EQU	3					* Out of cars
DMOEND EQU	4					* Demo ended	
EXPLOD EQU	-1
	   
**
* Sprite attribute offsets
*
SACAR  EQU	0
SACAR1 EQU	4
SACAR2 EQU	8
SACAR3 EQU	12
SACAR4 EQU	16
SACAR5 EQU	20
SACAR6 EQU	24
SACAR7 EQU	28
SACAS  EQU	32
SACAS1 EQU	36
SACAS2 EQU	40
SACAS3 EQU	44
SACAS4 EQU	48
SACAS5 EQU	52
SACAS6 EQU	56
SACAS7 EQU	60
SASHOT EQU	64

**
* Sprite pattern offsets
*
SPCR00 EQU	0					* Car 0 color 0
SPCR01 EQU	4					* Car 0 color 1 (shadow)
SPCR10 EQU	8					* Car 1 color 0
SPCR11 EQU	12					* Car 1 color 1 (shadow)
SPCR20 EQU	16					* Car 2 color 0
SPCR21 EQU	20					* Car 2 color 1 (shadow)
SPCR30 EQU	24					* Car 3 color 0
SPCR31 EQU	28					* Car 3 color 1 (shadow)
SPCR40 EQU	32					* Car 4 color 0
SPCR41 EQU	36					* Car 4 color 1 (shadow)
SPCR50 EQU	40					* Car 5 color 0
SPCR51 EQU	44					* Car 5 color 1 (shadow)
SPCR60 EQU	48					* Car 6 color 0
SPCR61 EQU	52					* Car 6 color 1 (shadow)
SPCR70 EQU	56					* Car 7 color 0
SPCR71 EQU	60					* Car 7 color 1 (shadow)
SPCRG0 EQU	64					* Car 8 color 0 (gun)
SPCRG1 EQU	68					* Car 8 color 1 (shadow)
SPEX00 EQU	72					* Explosion 0 color 0
SPEX01 EQU	76					* Explosion 0 color 1
SPEX10 EQU	80					* Explosion 1 color 0
SPEX11 EQU	84					* Explosion 1 color 1
SPEX20 EQU	88					* Explosion 2 color 0
SPEX21 EQU	92					* Explosion 2 color 1
SPEX30 EQU	96					* Explosion 3 color 0
SPEX31 EQU	100					* Explosion 4 color 1
SPFUL0 EQU	104					* Fuel color 0
SPFUL1 EQU	108					* Fuel color 1
SPGUN0 EQU	112					* Gun color 0
SPGUN1 EQU	116					* Gun color 1
SPOIL0 EQU	120					* Oil color 0
SPOIL1 EQU	124					* Oil color 1
SPSHOT EQU	128					* Shot
SPEM00 EQU	132					* Empty 0
SPEM01 EQU	132					* Empty 1

YPOS   EQU	SPRATT+SACAR+0		* Car y position
XPOS   EQU	SPRATT+SACAR+1		* Car x position
CARPAT EQU	SPRATT+SACAR+2		* Car pattern

*********************************************************************
*
* Main program execution starts here
*
SLOAD	   
SFIRST AORG	>A000

START  LIMI	0					* Disable interrupts
	   LWPI	TMPWS				* Use a temporary workspace
*	   Prepare for using PAD
	   MOV	@RNDSD,R15		    * Save random number seed
	   MOV	@>8370,@VDPTOP		* Save highest available address of VDP RAM
	   IF	CART
	   NOP						* No boot tracking for cart
	   ELSE
	   BL	@BOOTTR				* Boot tracking
	   ENDIF
	   BL	@SWPPAD				* Save contents of PAD
	   MOV	R15,@RANDNO	    	* Save random number seed
*	   Ready to go
	   LWPI	WRKSP
	   LI	R10,STACK			* Set up the stack pointer
*	   Init constants
	   LI	R0,>0001
	   MOV	R0,@ONE
	   LI	R0,>C000
	   MOV	R0,@SPROFF
*	   Move copy routine into scratch pad	   
	   LI	R0,VM8BW
	   LI	R1,VM8BW8
	   LI	R2,VM8BWE-VM8BW8/2
CPYPAD MOV	*R1+,*R0+
	   DEC	R2
	   JNE	CPYPAD
*	   Init graphics mode
	   BL	@GMODE
*	   Init static chars
	   LI	R0,COLRTB+24		* Colors for static characters
	   LI	R1,CLRST1
	   LI	R2,8
	   BL	@VMBW
	   LI	R0,192*8+PTRNT0		* Patterns for static characters
	   LI	R4,4
INISC1 LI	R1,PAT192
	   LI	R2,8*64
	   BL	@VMBW
	   AI	R0,>0800
	   DEC	R4
	   JNE	INISC1
*	   Display LOADING
	   LI	R0,9*32+10			* Box
	   LI	R1,11
	   LI	R2,5
	   BL	@DSPBOX
	   LI	R0,11*32+12			* Text
	   LI	R1,TXTLOD
	   LI	R2,7
	   BL	@DSPTXT	   
*	   New game	   
NEWGME LI	R0,SLEVEL
	   MOV	R0,@LEVEL			* Set start level
	   LI	R0,SCORE			* Init score
	   LI	R1,SC0000
	   LI	R2,6
INISCO MOVB *R1+,*R0+
	   DEC	R2
	   JNE	INISCO
	   LI	R0,NLIVES			* Init lives
	   MOV	R0,@LIVES
	   LI	R0,XLFSCO			* Extra life counter
	   MOV	R0,@XLFCNT
*	   Initialize level
NXTLVL BL	@RDMAP
	   BL	@INILVL
*	   Wait 2 seconds	   
	   LI	R2,120				 
	   BL	@WTKEY
*	   Display "GET READY"
	   LI	R0,19*32+7			* Box
	   LI	R1,11
	   LI	R2,3
	   BL	@DSPBOX
	   LI	R0,20*32+8			* Text
	   LI	R1,TXTRDY
	   LI	R2,9
	   BL	@DSPTXT
*	   Wait for up
	   LI	R2,600
	   BL	@WTKEY
	   MOV	R0,R0				* Check if a key way pressed
	   JNE	NXTLV1
*	   Demo	   
	   BL	@DEMO
	   BL	@MTESND
	   BL	@HIDSPR
	   JMP	NEWGME
NXTLV1 BL	@PLYMUS				*	   Start music
*********************************************************************
*
* Main loop
*
MAINLP BL	@SETSPD				* Set speed and delay
	   MOV	@DELAY,@DELAYT
*	   Wait for vsync
MAIN0  BL	@VSYNC
	   INC	@TICK
*	   Change name table 
	   BL	@CHGNT
*	   Change pattern table
	   BL	@CHGPT
*	   Change sprite attribute table
	   BL	@CHGST
*	   Check for road side collision
	   IF	CCRASH
	   BL	@RDCOL
	   ENDIF
*	   Check for shot collision
	   BL	@SHCOL
*	   Check for player car to sprite collision
	   BL	@SPCOL
*	   Check for collision between other cars	   
	   BL	@OCCOL
*	   Move car	   
	   BL	@MVCAR
*	   Create other cars
	   BL	@CRCARS
*	   Move other cars
	   BL	@MVCARS
*	   Move shot
	   BL	@MVSHOT
*	   Copy sprite attributes
	   BL	@CPYSPR
*	   Play sound
	   BL	@SNDPLR
*	   Consume fuel
	   BL	@CONFUL
*	   Pause key
	   BL	@PKEY
*	   Check for zero speed
	   MOV	@SCRLSP,R0
	   JEQ	MAINLP
*	   Delay	   
	   MOV	@DELAYT,R0
	   JEQ	MAIN1
	   DEC	@DELAYT
	   JMP	MAIN0
*	   Update off-screen name table buffer
MAIN1  BL	@UPDNT
*	   Change scroll offset
	   MOV	@SCRLSP,R0
	   A	R0,@SCRLY
*	   Update progress indicator
	   S	R0,@PGICNT
	   JNE	MAIN2
	   BL	@DSPPGI
	   LI	R0,MAPH
	   MOV	R0,@PGICNT
*	   Change screen row position and list pointer
MAIN2  BL	@UPDSCR 
*	   Loop
	   JMP	MAINLP	
*// Main loop
	  	  
*********************************************************************
*
* Demo
*
DEMO   MOV  R11,*R10+			* Push return address onto the stack
*	   Display "DEMO MODE"
	   LI	R0,20*32+8			* Text
	   LI	R1,TXTDMO
	   LI	R2,9
	   BL	@DSPTXT
	   LI	R2,60
DEMO4  BL	@VSYNC
	   DEC	R2
	   JNE	DEMO4
*	   Start music
	   BL	@PLYMUS
DEMOLP LI	R0,DMOEND
	   C	R0,@STATUS
	   JEQ	DEMO3
	   BL	@SETSPD				* Set speed and delay
	   MOV	@DELAY,@DELAYT
*	   Wait for vsync
DEMO0  BL	@VSYNC
	   INC	@TICK
*	   Change name table 
	   BL	@CHGNT
*	   Change pattern table
	   BL	@CHGPT
*	   Change sprite attribute table
	   BL	@CHGST
*	   Check for road side collision	   
	   BL	@RDCOL
*	   Check for shot collision
	   BL	@SHCOL
*	   Check for player car to sprite collision
	   BL	@SPCOL
*	   Check for collision between other cars	   
	   BL	@OCCOL
*	   Move car	   
	   BL	@MVDMO
*	   Create other cars
	   BL	@CRCARS
*	   Move other cars
	   BL	@MVCARS
*	   Move shot
	   BL	@MVSHOT
*	   Copy sprite attributes
	   BL	@CPYSPR
*	   Play sound
	   BL	@SNDPLR
*	   Consume fuel
	   BL	@CONFUL
*	   Check for zero speed
	   MOV	@SCRLSP,R0
	   JEQ	DEMOLP
*	   Delay	   
	   MOV	@DELAYT,R0
	   JEQ	DEMO1
	   DEC	@DELAYT
	   JMP	DEMO0
*	   Update off-screen name table buffer
DEMO1  BL	@UPDNT
*	   Change scroll offset
	   MOV	@SCRLSP,R0
	   A	R0,@SCRLY
*	   Update progress indicator
	   S	R0,@PGICNT
	   JNE	DEMO2
	   BL	@DSPPGI
	   LI	R0,MAPH
	   MOV	R0,@PGICNT
*	   Change screen row position and list pointer
DEMO2  BL	@UPDSCR 
*	   Loop
	   JMP	DEMOLP	
*	   Return
DEMO3  DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// Demo

*********************************************************************
*
* Next level initialization
*
INILVL MOV  R11,*R10+			* Push return address onto the stack
*	   Update level data pointer
	   CLR	R0
	   MOV	@LEVEL,R1			* Get the level
	   LI	R2,NMAPS			* Divide by available maps
	   DIV	R2,R0				* Remainder in R1
	   LI	R0,LVLSIZ			* Multiply by structure size
	   MPY	R0,R1				* Result in R2
	   AI	R2,LEVELS			* Add base address
	   MOV	R2,@LVLDAT			* Store it
*	   Mute sound
	   BL	@MTESND
*	   Init panel
	   LI	R0,NAMET0+24
	   BL	@INIPNL
	   LI	R0,NAMET1+24
	   BL	@INIPNL
*	   Display score
	   LI	R0,32*5+25
	   LI	R1,SCORE
	   BL	@DSPSCR				* Display high score
*	   Display high score
	   LI	R0,32*2+25
	   LI	R1,HSCORE
	   BL	@DSPSCR				* Display high score
*	   Display lives	   
	   BL	@DSPLIV
*      Black out colors for scrolling tiles
	   LI	R0,COLRTB
	   CLR	R1
	   LI	R2,24
	   BL	@VSMW
*	   Init scrolling part of name table
	   LI	R0,NAMET0
	   LI	R1,SCR000
	   LI	R2,24
	   BL	@VMLW
	   LI	R0,>0208			* NAMET0
	   BL   @VWTR
*	   Scroll and upload patterns into VDP RAM	   
	   BL	@SCRLPT
*	   Color set for scrolling tiles
	   LI	R0,COLRTB
	   MOV	@LVLDAT,R1			* Get level data address
	   MOV	@CLRST_(R1),R1
	   LI	R2,24
	   BL	@VMBW
*	   Init sprites
	   CLR	@SPRTBL
	   BL	@INISPR				* Upload to SPRTB0
	   BL	@CHGST				* Change to SPRTB0
	   CLR	@SPRTBL
*	   Reset y coordinates of other cars	   
	   LI	R0,CAR1Y
	   LI	R1,CARYI
	   LI	R2,NCARS
INILV1 MOV	*R1+,*R0+
	   DEC	R2
	   JNE	INILV1
*	   Reset speed of other cars	   
	   LI	R0,CAR1DY
	   LI	R1,3
	   LI	R2,3
INILV2 MOV	R1,*R0+
	   DEC	R2
	   JNE	INILV2
	   LI	R1,3
	   LI	R2,2
INILV3 MOV	R1,*R0+
	   DEC	R2
	   JNE	INILV3
	   LI	R1,3
	   LI	R2,2
INILV4 MOV	R1,*R0+
	   DEC	R2
	   JNE	INILV4
*	   Reset path of other cars	   
	   LI	R0,CAR1PT
	   LI	R2,NCARS
INILV5 CLR	*R0+
	   DEC	R2
	   JNE	INILV5
*	   Init variables for main loop
	   CLR	@TICK				* Vsync counter
	   CLR	@SCRLY				* Scroll offset
	   CLR	@SCRLSP				* Scroll speed
	   MOV	@LVLDAT,R1			* Get level data address
	   MOV	@SCRL_(R1),@SCRPTR	* Screen pointer
	   MOV	@RDDXL_(R1),@RDXPTR	* Road direction list pointer
	   MOV	@ROADX_(R1),@ROADX	* Road x position
	   MOV	@ROADW_(R1),@ROADW  * Road width 
	   LI	R0,23				* Screen row position
	   MOV	R0,@ROWPOS
	   LI	R0,64				* Fuel
	   MOV	R0,@FUEL			
	   CLR	@SPEED				* Speed
	   CLR	@NSHOTS				* Reset shots
	   CLR	@DX					* Movement direction
	   CLR	@STATUS				* Set status to OK
	   CLR	@CARPTH				* Car path
	   LI	R0,MAPH				* Progress indicator
	   MOV	R0,@PGICNT
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// INILVL

*********************************************************************
*
* Level complete
*
LVLCMP BL	@MTESND
	   BL	@HIDSPR
*	   Display box
	   LI	R0,10*32+3
	   LI	R1,17
	   LI	R2,3
	   BL	@DSPBOX
*	   Display "TRACK COMPLETED"
	   LI	R0,11*32+4
	   LI	R1,TXTTRK
	   LI	R2,15
	   BL	@DSPTXT
*	   Bonus for fuel left
	   BL	@PLYBON
LVLCM1 MOV	@FUEL,R0
	   JEQ	LVLCM2
	   DEC	R0
	   MOV	R0,@FUEL
	   LI	R0,SC0025
	   BL	@ADDSCR
	   BL	@DSPFUL
	   BL	@VSYNC
	   BL	@SNDPLR
	   BL	@VSYNC
	   BL	@SNDPLR
	   JMP	LVLCM1
LVLCM2 BL	@MTESND
*	   Next level
	   INC	@LEVEL
	   B	@NXTLVL
*// LVLCMP

*********************************************************************
*
* Game over
*
LVLEND BL	@MTESND
	   BL	@HIDSPR
*	   Display box
	   LI	R0,8*32+4
	   LI	R1,15
	   LI	R2,6
	   BL	@DSPBOX
*	   Display "GAME OVER"
	   LI	R0,10*32+7
	   LI	R1,TXTGMO
	   LI	R2,9
	   BL	@DSPTXT
*	   Decide which text to display
	   MOV	@STATUS,R0
	   CI	R0,NOCARS
	   JEQ	LVLEN1
*	   Display "OUT OF FUEL"
	   LI	R1,TXTOOF
	   JMP	LVLEN2
*	   Display "OUT OF CARS"
LVLEN1 LI	R1,TXTOOC
LVLEN2 LI	R0,11*32+6
	   LI	R2,11
	   BL	@DSPTXT
*	   New game
	   B	@NEWGME
*// LVLEND		  
		  
*********************************************************************
*
* Wait for vsync
*
VSYNC  CLR	@COINC
	   MOVB	@VDPSTA,R0
VSYNC1 MOVB	@VDPSTA,R0
	   MOV	R0,R1
	   ANDI R1,>2000
	   SOC	R1,@COINC			* Save coincidence flag
	   ANDI	R0,>8000
	   JEQ	VSYNC1				* Wait for vsync
	   B	*R11
*// VSYNC	   

*********************************************************************
*
* Change name table
*
* @SCRLY: Scroll offset
* 
* Modifies R0
*
CHGNT  MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@SCRLY,R0
	   ANDI	R0,>0008
	   JNE	CHGNT1
	   LI	R0,>0208			* NAMET0
	   JMP	CHGNT2
CHGNT1 LI	R0,>0209			* NAMET1
CHGNT2 BL   @VWTR				* Set address of name table
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CHGNT

*********************************************************************
*
* Change pattern table
*
* @SCRLY: Scroll offset
*
* Modifies R0
*
CHGPT  MOV  R11,*R10+			* Push return address onto the stack 
	   MOV	@SCRLY,R0
	   ANDI	R0,>0006
	   SRL	R0,1
	   ORI	R0,>0400			* VDP register 4
	   BL   @VWTR				* Set address of name table
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CHGPT

*********************************************************************
*
* Change sprite atttribute table
*
* Modifies R0
*
CHGST  MOV  R11,*R10+			* Push return address onto the stack 
	   MOV	@SPRTBL,R0
	   JNE	CHGST1
	   LI   R0,>054E			* SPRAT0 = >2700 (>4E * >80)
	   SETO	@SPRTBL
	   JMP	CHGST2
CHGST1 LI   R0,>054F			* SPRAT1 = >2780 (>4F * >80)
	   CLR @SPRTBL
CHGST2 BL   @VWTR				* Set sprite attribute table
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CHGST

*********************************************************************
*
* Update one quarter or one half of the double buffer name table
* depending on scrolling speed, reparing to move up one character 
* row of 8 pixels
*
* @SCRLY: Scroll offset
* @SCRLSP: Scroll speed
*
* Modifies R0-R6, R14-R15
*
UPDNT  MOV  R11,*R10+			* Push return address onto the stack
*	   Row offset from top	   
	   MOV	@SCRLY,R5
	   ANDI	R5,>0006			* 0, 2, 4, 6
	   MOV	R5,R0
	   SLA	R5,1				* 0, 4, 8, 12
	   A	R0,R5				* 0, 6, 12, 18
*	   Total rows to copy
	   MOV	@SCRLSP,R6
	   SLA	R6,1
	   A	@SCRLSP,R6			* Speed * 3
*	   Destination address
	   MOV	R5,R0				* Row offset from top
	   SLA	R0,5				* Byte offset from top
	   MOV	@SCRLY,R1
	   ANDI	R1,>0008
	   JNE	UPDNT1
	   AI	R0,NAMET1
	   JMP	UPDNT2
UPDNT1 AI	R0,NAMET0
*	   Top part of screen
UPDNT2 MOV	@ROWPOS,R1
	   A	R5,R1				* Total row offset
	   LI	R2,24				* Rows on screen
	   S	R1,R2				* Rows left
	   JLT	UPDNT4				* If negative or zero 
	   JEQ	UPDNT4				* there are no rows to display 
	   C	R6,R2				* Compare to total rows
	   JGT	UPDNT3
	   MOV	R6,R2				* Set to total rows
UPDNT3 S	R2,R6				* Subtract from total rows
*	   Source address
	   LI	R14,MAPW
	   MPY	R1,R14				* Byte offset in R15
	   MOV	@SCRPTR,R1			* Get screen list pointer
	   INCT	R1					* Need top (next) screen
	   MOV	*R1,R1				* Get screen address
	   A	R15,R1				* Add byte offset
*	   Copy top part
	   BL	@VMLW
*	   Bottom part of screen
UPDNT4 MOV	R6,R2				* Get rows left to copy
	   JEQ	UPDNT6
	   MOV	@ROWPOS,R1
	   A	R5,R1
	   AI	R1,-24
	   JGT	UPDNT5
	   CLR	R1					* Start at top
*	   Source address
UPDNT5 LI	R14,MAPW
	   MPY	R1,R14				* Byte offset in R15
	   MOV	@SCRPTR,R1			* Get screen list pointer
	   MOV	*R1,R1				* Get screen address
	   A	R15,R1				* Add byte offset
*	   Copy bottom part
	   BL	@VMLW
*	   Return
UPDNT6 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// UPDNT
	   
*********************************************************************
*
* Check for road side collision
*
* Modifies R0-R4
*
RDCOL  MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@STATUS,R0
	   JNE	RDCOL8				* Skip if already exploded/won/lost
*	   Check collision with road side
	   LI	R0,STARTY+8/8
	   BL	@RDPOS				* Get road position in R1
	   CLR	R0
	   MOVB	@XPOS,@R0LB
	   S	R1,R0
	   CI	R0,-3
	   JLT	RDCOL1
	   S	@ROADW,R0
	   CI	R0,3
	   JGT	RDCOL4
	   JMP	RDCOL8
*	   Collision
RDCOL1 MOV	@SCRLSP,R0
	   CI	R0,4
	   JEQ	RDCOL2
	   CI	R0,2
	   JEQ	RDCOL3
	   LI	R0,CPATH5
	   JMP	RDCOL7
RDCOL2 SETO	@STATUS				* Set status to exploded
	   BL	@PLYXP2				* Explosion sound
	   LI	R0,CPATH9
	   JMP	RDCOL7
RDCOL3 LI	R0,CPATH1
	   JMP	RDCOL7
RDCOL4 MOV	@SCRLSP,R0
	   CI	R0,4
	   JEQ	RDCOL5
	   CI	R0,2
	   JEQ	RDCOL6
	   LI	R0,CPATH6
	   JMP	RDCOL7
RDCOL5 SETO	@STATUS				* Set status to exploded
	   BL	@PLYXP2				* Explosion sound
	   LI	R0,CPATH8
	   JMP	RDCOL7
RDCOL6 LI	R0,CPATH2
	   JMP	RDCOL7
RDCOL7 MOV	R0,@CARPTH
*	   Return
RDCOL8 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// RDCOL
	   
*********************************************************************
*
* Check for shot collision
*
* Modifies R0-R9
*
SHCOL  MOV  R11,*R10+			* Push return address onto the stack
*	   Check for shot in progress
	   CB	@SPROFF,@SASHOT+SPRATT
	   JEQ	SHCOL4
*	   Check hardware flag	   
*	   MOV	@COINC,R0
*	   JEQ	SHCOL4
*	   Find car that shot is hitting
	   CLR	R0					* Get shot x
	   MOVB	@SASHOT+SPRATT+1,@R0LB
	   CLR	R1					* Get shot y
	   MOVB	@SASHOT+SPRATT,@R1LB
	   LI	R4,NCARS			* Counter
	   LI	R5,SPRATT+SACAR1	* Sprite attribute address
	   LI	R6,CAR1PT
	   LI	R7,CAR1DY
	   LI	R9,CAR1Y
SHCOL2 MOV	*R9,R3				* Check if visible
	   JEQ	SHCOL3
	   MOV	*R7,R3				* Check if speed < 0, i.e. exploded
	   JLT	SHCOL3
	   CB	@OPAT0B,@2(R5)		* Don't shoot the oil spills
	   JEQ	SHCOL3
	   CLR	R3					* Get other car y
	   MOVB	*R5,@R3LB
	   S	R1,R3				* Distance from main car y
	   CI	R3,15
	   JGT	SHCOL3
	   CI	R3,-15
	   JLT	SHCOL3	   
	   CLR	R2					* Get other car x
	   MOVB	@1(R5),@R2LB
	   S	R0,R2				* Distance from main car x
	   CI	R2,15
	   JGT	SHCOL3
	   CI	R2,-15
	   JLT	SHCOL3
*	   Found a car that's hit	   
	   LI	R8,CPATH7
	   MOV	R8,*R6	
	   SETO	*R7					* Zero speed
	   BL	@PLYXP1				* Explosion sound
	   LI	R0,SC0075			* Add score
	   BL	@ADDSCR
*	   Turn shot off
	   MOV	@SPROFF,@SASHOT+SPRATT
	   JMP	SHCOL4				* Break out
*	   Next car	   
SHCOL3 AI	R5,4
	   INCT	R6
	   INCT R7
	   INCT R9
	   DEC	R4
	   JNE	SHCOL2
*	   Return
SHCOL4 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// SHCOL

*********************************************************************
*
* Check for player car to other car/fuel/gun/oil sprite collision
*
* Modifies R0-R9
*
SPCOL  MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@COINC,R0			* Check hardware flag
	   JNE	SPCOL1
	   B	@SPCOL8				* Return if not set
*	   Check if another sprite overlaps with main car
SPCOL1 CLR	R0
	   MOVB	@XPOS,@R0LB			* Get main car x
	   CLR	R1
	   MOVB	@YPOS,@R1LB			* Get main car y			
	   LI	R4,NCARS			* Counter
	   LI	R5,SPRATT+SACAR1	* Sprite attribute address
	   LI	R6,CAR1PT
	   LI	R7,CAR1DY
	   LI	R9,CAR1Y
SPCOL2 MOV	*R9,R3				* Check if visible
	   JEQ	SPCOL3
	   MOV	*R7,R3				* Check if speed < 0, i.e. exploded
	   JLT	SPCOL3
	   CLR	R3					* Get other car y
	   MOVB	*R5,@R3LB
	   S	R1,R3				* Distance from main car y
	   CI	R3,15
	   JGT	SPCOL3
	   CI	R3,-15
	   JLT	SPCOL3	   
	   CLR	R2					* Get other car x
	   MOVB	@1(R5),@R2LB
	   S	R0,R2				* Distance from main car x
	   CI	R2,15
	   JGT	SPCOL3
	   CI	R2,-15
	   JLT	SPCOL3
*	   Found something
*	   CLR	@COINC				* No more collision detection this frame
	   CB	@FPAT0B,@2(R5)		* Check for fuel
	   JEQ	SPCOL4
	   CB	@GPAT0B,@2(R5)		* Check for gun
	   JEQ	SPCOL6
	   CB	@OPAT0B,@2(R5)		* Check for oil
	   JEQ	SPCOL7
*	   Found car
	   IF	CHITS
	   BL	@CARHIT
	   ENDIF
	   JMP	SPCOL8
*	   Next car	   
SPCOL3 AI	R5,4
	   INCT	R6
	   INCT R7
	   INCT R9
	   DEC	R4
	   JNE	SPCOL2
	   JMP	SPCOL8
*	   Found fuel
SPCOL4 LI	R0,16
	   A	@FUEL,R0
	   CI	R0,64
	   JLT	SPCOL5
	   LI	R0,64 
SPCOL5 MOV	R0,@FUEL
	   CLR	@STATUS				* Set status to OK
	   CLR	*R9					* Disable sprite
	   MOVB	@SPROFF,*R5
	   MOVB	@SPROFF,@SPROFS(R5)
	   BL	@PLYBNG				* Play sound
	   LI	R0,SC0025			* Add score
	   BL	@ADDSCR
	   JMP	SPCOL8
*	   Found gun	   
SPCOL6 MOV	@NSHOTS,R0
	   AI	R0,10
	   MOV	R0,@NSHOTS
	   CLR	*R9					* Disable sprite
	   MOVB	@SPROFF,*R5
	   MOVB	@SPROFF,@SPROFS(R5)
	   MOVB	@CPAT0G,@CARPAT	   
	   MOVB	@CPAT1G,@CARPAT+SPROFS	   
	   BL	@PLYZZZ				* Play sound
	   LI	R0,SC0050			* Add score
	   BL	@ADDSCR
	   JMP	SPCOL8
*	   Found oil	   
SPCOL7 MOV	@CARPTH,R0			* Check for exiting path
	   JNE	SPCOL8
	   MOV	@DELAY,R0			* or if a delay is effective.
	   JNE	SPCOL8	  
	   LI	R0,CPATHA
	   MOV	R0,@CARPTH
	   JMP	SPCOL8
*	   Return
SPCOL8 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// SPCOL

*********************************************************************
*
* Other car hit by player car
*
* R2: x distance from main car
* R3: y distance from main car
*
CARHIT MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@SCRLSP,R9
	   CI	R9,4				* Get scroll speed
	   JEQ	CARHT1
	   CLR R9					* Clear flag if 2 or 0
	   JMP	CARHT2
CARHT1 SETO	R9	   				* Set flag if 4
CARHT2 CI	R3,-9				* Check if hit from back
	   JLT	CARHT3
	   CI	R3,9				* Check if hit from front
	   JGT	CARHT9
*	   Middle hit
	   MOV	R2,R2				* Check if hit from right or left
	   JGT	CARHTA				* From right
	   JLT	CARHTF				* From left
*	   Middle hit, but not left or right (?)
	   MOV	*R7,R0
	   CI	R0,4
	   JGT	CARHTK
	   INC	*R7					* Increase speed of other car
	   BL	@PLYBOI				* Play sound
	   JMP	CARHTK
*	   Hit from back	  
CARHT3 MOV	R2,R2
	   JGT	CARHT4
	   JLT	CARHT6
*	   Back center
	   LI	R8,CPATH0
	   JMP	CARHT8
*	   Back right
CARHT4 ABS	R9					* Test speed flag
	   JNE	CARHT5
*	   Back right speed 2
	   LI	R8,CPATH2
	   JMP	CARHT8
*	   Back right speed 4
CARHT5 LI	R8,CPATH4
	   JMP	CARHT8
*	   Back left
CARHT6 ABS	R9					* Test speed flag
	   JNE	CARHT7
*	   Back left speed 2
	   LI	R8,CPATH1
	   JMP	CARHT8	   
*	   Back left speed 4
CARHT7 LI	R8,CPATH3
	   JMP	CARHT8
*	   Set path
CARHT8 MOV	@STATUS,R0			* Check status
	   JLT	CARHTL				* Skip if already exploded
	   MOV	R8,@CARPTH			* Set new path
*	   Hit other car
CARHTL MOV	R2,R2
	   JGT	CARHTD				* From right
	   JLT	CARHTI				* From left
*	   Hit other center, increase speed
	   INC	*R7
	   BL	@PLYBOI				* Play sound
	   JMP	CARHTK
*	   Hit from front
CARHT9 LI	R8,CPATH7			* Explode
	   MOV	R8,*R6	
	   SETO	*R7					* Set speed to -1, i.e. exploded
	   BL	@PLYXP1				* Explosion sound
	   LI	R0,SC0100			* Add score
	   BL	@ADDSCR
	   JMP	CARHTK
*	   Hit from right	   	   
CARHTA ABS	R9					* Test speed flag
	   JNE	CARHTB
*	   Right speed 2
	   LI	R8,CPATH6
	   JMP	CARHTC
*	   Right speed 4
CARHTB LI	R8,CPATH2
*	   Set path
CARHTC MOV	R8,@CARPTH
	   BL	@PLYBOI				* Play sound
	   LI	R0,SC0010			* Add score
	   BL	@ADDSCR
*	   Path of other car
CARHTD ABS	R9					* Test speed flag
	   JNE	CARHTE
*	   Right speed 2
	   LI	R8,CPATH5
	   MOV	R8,*R6
	   JMP	CARHTK
*	   Right speed 4
CARHTE LI	R8,CPATH1
	   MOV	R8,*R6
	   JMP	CARHTK
*	   Hit from left
CARHTF ABS	R9
	   JNE	CARHTG
*	   Left speed 2
	   LI	R8,CPATH5
	   JMP	CARHTH
*	   Left speed 4
CARHTG LI	R8,CPATH1
*	   Set path
CARHTH MOV	R8,@CARPTH
	   BL	@PLYBOI				* Play sound
	   LI	R0,SC0010			* Add score
	   BL	@ADDSCR
*	   Path of other car
CARHTI ABS	R9					* Test speed flag
	   JNE	CARHTJ
*	   Left speed 2
	   LI	R8,CPATH6
	   MOV	R8,*R6
	   JMP	CARHTK
*	   Left speed 4
CARHTJ LI	R8,CPATH2
	   MOV	R8,*R6
	   JMP	CARHTK
*	   Return
CARHTK DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// CARHIT

*********************************************************************
*
* Check for collision between other cars
*
OCCOL  MOV  R11,*R10+			* Push return address onto the stack
*	   MOV	@COINC,R0			* Check hardware flag
*	   JEQ	OCCOL5
	   CLR	R4					* Outer loop counter
	   LI	R5,SPRATT+SACAR1	* Outer loop sprite attributes
*	   Outer loop
OCCOL1 MOV	@CAR1Y(R4),R8		* Check y position
	   JEQ	OCCOL4				* Zero means not visible
	   S	@SCRLY,R8			* Convert to inverted screen coordinates
	   JLT	OCCOL4				* Check of out of screen bottom
	   CI	R8,192+8			* Check of out of screen top
	   JGT	OCCOL4				* Out if screen top
	   MOV	@CAR1DY(R4),R8		* Check y speed
	   JLT	OCCOL4				* -1 means exploded
	   CB	@CPAT0B,@2(R5)		* Check if pattern is a car
	   JNE	OCCOL4				* Skip sprite if not
	   CLR	R0
	   MOVB	@1(R5),@R0LB		* Get outer car x
	   CLR	R1
	   MOVB	*R5,@R1LB			* Get outer car y			
	   MOV	R4,R6				* Inner loop counter
	   INCT	R6					* Start with next car
	   MOV	R5,R7				* Inner loop sprite attributes
	   AI	R7,4				* Start with next sprite
*	   Inner loop
OCCOL2 MOV	@CAR1Y(R6),R8		* Check y position
	   JEQ	OCCOL3				* Zero means not visible
	   MOV	@CAR1DY(R6),R8		* Check y speed
	   JLT	OCCOL3				* -1 means exploded
	   CB	@CPAT0B,@2(R7)		* Check if pattern is a car
	   JNE	OCCOL3				* Skip sprite if not
	   CLR	R2					* Get inner car x
	   MOVB	@1(R7),@R2LB
	   S	R0,R2				* Distance from outer car x
	   CI	R2,15
	   JGT	OCCOL3				* Loop if distance too big
	   CI	R2,-15
	   JLT	OCCOL3				* Loop if distance too big
	   CLR	R3					* Get inner car y
	   MOVB	*R7,@R3LB
	   S	R1,R3				* Distance from other car y
	   CI	R3,15
	   JGT	OCCOL3				* Loop if distance too big
	   CI	R3,-15
	   JLT	OCCOL3	   			* Loop if distance too big
*	   Found a collision
	   BL	@OCHIT
	   JMP	OCCOL5				* Break out
*	   Inner loop end
OCCOL3 INCT	R6
	   AI	R7,4				* Next sprite
	   CI	R6,NCARS*2
	   JNE	OCCOL2
*	   Outer loop end
OCCOL4 INCT	R4
	   AI	R5,4				* Next sprite
	   CI	R4,NCARS-1*2
	   JNE	OCCOL1
*	   Return
OCCOL5 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// OCCOL

*********************************************************************
*
* Other car hit by other car
*
* R2: x distance between cars
* R3: y distance between cars
* R4: Index of 1st car * 2
* R5: Sprite attributes of 1st car
* R6: Index of 2nd car * 2
* R7: Sprite attributes of 2nd car
*
OCHIT  MOV  R11,*R10+			* Push return address onto the stack
	   CI	R3,-11				* Check if 2nd hit from back
	   JLT	OCHIT3
	   CI	R3,11				* Check if 2nd hit from front
	   JGT	OCHIT6
*	   Middle hit
	   MOV	R2,R2				* Get x distance
	   JGT	OCHIT1				* From right
	   JLT	OCHIT2				* From left
*	   Middle center
	   JMP	OCHIT9				* This should not happen
*	   Middle right
OCHIT1 LI	R0,CPATH6
	   MOV	R0,@CAR1PT(R4)
	   LI	R0,CPATH5
	   MOV	R0,@CAR1PT(R6)
	   JMP	OCHIT9
*	   Middle left	   
OCHIT2 LI	R0,CPATH5
	   MOV	R0,@CAR1PT(R4)
	   LI	R0,CPATH6
	   MOV	R0,@CAR1PT(R6)	   
	   JMP	OCHIT9 
*	   2nd car hit from back	  
OCHIT3 MOV	R2,R2
	   JGT	OCHIT4
	   JLT	OCHIT5
*	   Back center
	   INC	@CAR1DY(R6)			* Increase speed of 2nd car
	   JMP	OCHIT9
*	   Back right
OCHIT4 LI	R0,CPATH2
	   MOV	R0,@CAR1PT(R4)
	   LI	R0,CPATH3
	   MOV	R0,@CAR1PT(R6)
	   JMP	OCHIT9
*	   Back left  
OCHIT5 LI	R0,CPATH1
	   MOV	R0,@CAR1PT(R4)
	   LI	R0,CPATH4
	   MOV	R0,@CAR1PT(R6)
	   JMP	OCHIT9
*	   2nd car hit from front	  
OCHIT6 MOV	R2,R2
	   JGT	OCHIT7
	   JLT	OCHIT8
*	   Front center
	   INC	@CAR1DY(R4)			* Increase speed of 1st car
	   JMP	OCHIT9
*	   Front right
OCHIT7 LI	R0,CPATH4
	   MOV	R0,@CAR1PT(R4)
	   LI	R0,CPATH1
	   MOV	R0,@CAR1PT(R6)
	   JMP	OCHIT9
*	   Front left  
OCHIT8 LI	R0,CPATH3
	   MOV	R0,@CAR1PT(R4)
	   LI	R0,CPATH2
	   MOV	R0,@CAR1PT(R6)
	   JMP	OCHIT9
*	   Return
OCHIT9 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// OCHIT

*********************************************************************
*
* Check status, move car, read keyboard/joystick
*
MVCAR  MOV  R11,*R10+			* Push return address onto the stack
*	   Check if path in progress
	   MOV	@CARPTH,R0
	   JEQ	MVCARF	
	   B	@MVCAR6				* Execute path
*	   Check if exploded or finished	   
MVCARF MOV	@STATUS,R0			* Check status
	   JEQ	MVCAR0				* Zero means OK
	   MOV	@SPEED,R0			* Check speed
	   JEQ	MVCARG
	   B	@MVCARA				* Slow down until stopped
*	   Was exploded or finished
MVCARG MOV	@STATUS,R0
	   JLT	MVCARE				* Negative means exploded
*	   Level complete or out of fuel
	   DECT R10					* Adjust stack
	   CI	R0,COMPLT
	   JNE	MVCARC
	   B	@LVLCMP				* Branch out to level complete
MVCARC B	@LVLEND				* Branch out to level end
*	   Exploded
MVCARE IF	FINLVS
	   DEC	@LIVES				* Decrement lives
	   ENDIF
	   JNE	MVCARB
	   LI	R0,NOCARS			* Set status to out of cars
	   MOV	R0,@STATUS
	   DECT R10					* Adjust stack
	   B	@LVLEND				* Branch out to level end
*	   Set back on road
MVCARB BL	@DSPLIV				* Display lives
	   CLR	@STATUS
	   LI	R0,STARTY+8/8
	   BL	@RDPOS				* Get road position
	   AI	R1,28				* Move to center
	   SWPB	R1
	   MOVB R1,@XPOS
	   MOVB R1,@XPOS+SPROFS
	   MOVB	@CPAT0B,@CARPAT
	   MOVB	@CPAT1B,@CARPAT+SPROFS
	   CLR	@NSHOTS
	   B	@MVCARD				* Return
*	   Read keyboard column 0 (Space)
MVCAR0 CLR  R1                  * Test column 0
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
       LI   R12,>0006           * Address to read rows
       STCR R13,8
*	   Read keyboard column 1 (S, X)
	   LI   R1,>0100            * Test column 1
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
       LI   R12,>0006           * Address to read rows
       STCR R14,8
*	   Read keyboard column 2 (E, D)
	   LI   R1,>0200            * Test column 2
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
       LI   R12,>0006           * Address to read rows
       STCR R15,8
*	   Read joystick
	   LI   R12,>0024	  		* CRU address of the column decoder 
	   LI   R1,>0600	   		* Column 6, i.e joystick #1
	   LDCR R1,3		   		* Select it
	   LI   R12,>0006			* Base CRU address for joystick 1
	   CLR	@DX
*	   Check for right
	   TB	2
	   JNE	MVCARH
	   MOV	R15,R0				* Keyboard column 2
	   ANDI	R0,>2000			* Mask off D
	   JNE	MVCAR1
MVCARH MOV	@ONE,@DX
	   JMP	MVCAR2
*	   Check for left
MVCAR1 TB	1
	   JNE	MVCARI
	   MOV	R14,R0				* Keyboard column 1
	   ANDI	R0,>2000  			* Mask off S
	   JNE	MVCAR3
MVCARI SETO	@DX
MVCAR2 CLR	R0
	   MOVB	@XPOS,@R0LB
	   A	@DX,R0
	   SWPB	R0
	   MOVB	R0,@XPOS
	   MOVB	R0,@XPOS+SPROFS
MVCAR3 MOV	@TICK,R0
	   ANDI	R0,>0003			* Only permit speed changes
	   JNE	MVCAR5				* every 4 frames 
*	   Check for up / speed
	   TB	4
	   JNE	MVCARJ
	   MOV	R15,R0				* Keyboard column 2
	   ANDI R0,>4000			* Mask off E
	   JNE	MVCAR4
MVCARJ MOV	@SPEED,R0
	   CI	R0,MAXSPD-1
	   JGT	MVCAR5
	   INC	@SPEED
	   BL	@DSPSPD
	   JMP	MVCAR5
*	   Check for down / brake
MVCAR4 TB	3
	   JNE	MVCARK
	   MOV	R14,R0				* Keyboard column 2
	   ANDI R0,>8000			* Mask off X
	   JNE	MVCARA
MVCARK DECT	@SPEED
	   DECT	@SPEED
	   JGT	MVCARM
	   JEQ	MVCARM
	   CLR	@SPEED
MVCARM BL	@DSPSPD
	   JMP	MVCAR5
*	   Slow down	   
MVCARA MOV	@SPEED,R0
	   CI	R0,1
	   JLT	MVCAR5
	   DEC	@SPEED
	   BL	@DSPSPD
	   JMP	MVCARD
*	   Move car along path
MVCAR6 MOV	@TICK,R1			* Only move car
	   COC	@ONE,R1				* every 2nd frame
	   JEQ	MVCARD
	   AB	*R0,@XPOS
	   AB	*R0+,@XPOS+SPROFS
	   MOVB	*R0+,R1
	   MOVB	R1,@CARPAT
	   AI	R1,>0400
	   MOVB	R1,@CARPAT+SPROFS
	   MOV	R0,@CARPTH 
*	   Slow down
	   MOV	@TICK,R0
	   ANDI	R0,>0003			* Only permit speed changes
	   JNE	MVCAR7				* every 4 frames
	   MOV	@SPEED,R0
	   CI	R0,2
	   JLT	MVCAR8
	   DECT	@SPEED
	   JMP	MVCAR9
MVCAR8 CLR	@SPEED	   
MVCAR9 BL	@DSPSPD
*	   Next path segment
MVCAR7 MOV	@CARPTH,R0
	   CB	@SPROFF,*R0
	   JNE	MVCARD
	   CLR	@CARPTH
	   CLR	@NSHOTS
	   JMP	MVCARD
*	   Check fire
MVCAR5 TB	0
	   JNE	MVCARL
	   ANDI R13,>0200           * Mask off space bar
	   JNE	MVCARD
MVCARL MOV	@NSHOTS,R0
	   IF	FINFIR
	   JEQ	MVCARD
	   ENDIF
	   CB	@SPROFF,@SASHOT+SPRATT
	   JNE	MVCARD
*	   Fire	   
	   BL	@PLYZAP
	   MOVB	@XPOS,@SASHOT+SPRATT+1
	   LI	R0,STARTY-16*256
	   MOVB	R0,@SASHOT+SPRATT
	   DEC	@NSHOTS
	   JNE	MVCARD
	   MOVB	@CPAT0B,@CARPAT
	   MOVB	@CPAT1B,@CARPAT+SPROFS
*	   Return	   
MVCARD DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// MVCAR

*********************************************************************
*
* Move car for demo
*
MVDMO  MOV  R11,*R10+			* Push return address onto the stack
*	   Check if path in progress
	   MOV	@CARPTH,R0
	   JEQ	MVDMOF	
	   B	@MVDMO6				* Execute path
*	   Check if exploded or finished	   
MVDMOF MOV	@STATUS,R0			* Check status
	   JEQ	MVDMO0				* Zero means OK
	   MOV	@SPEED,R0			* Check speed
	   JEQ	MVDMOG
	   B	@MVDMOA				* Slow down until stopped
*	   Was exploded or finished
MVDMOG MOV	@STATUS,R0
	   JLT	MVDMOE				* Negative means exploded
	   JMP	MVDMOC
*	   Exploded
MVDMOE DEC	@LIVES				* Decrement lives
	   JNE	MVDMOB
MVDMOC LI	R0,DMOEND
	   MOV	R0,@STATUS			* Signal end of demo
	   B	@MVDMOD				* Return
*	   Set back on road
MVDMOB BL	@DSPLIV				* Display lives
	   CLR	@STATUS
	   LI	R0,STARTY+8/8
	   BL	@RDPOS				* Get road position
	   AI	R1,28				* Move to center
	   SWPB	R1
	   MOVB R1,@XPOS
	   MOVB R1,@XPOS+SPROFS
	   MOVB	@CPAT0B,@CARPAT
	   MOVB	@CPAT1B,@CARPAT+SPROFS
	   CLR	@NSHOTS
	   B	@MVDMOD				* Return
*	   Read keyboard column 0 (Space)
MVDMO0 CLR  R1                  * Test column 0
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
       LI   R12,>0006           * Address to read rows
       STCR R13,8
	   ANDI R13,>0200           * Mask off space bar
	   JEQ	MVDMOC				* Finish demo if pressed
*	   Read joystick
	   LI   R12,>0024	  		* CRU address of the column decoder 
	   LI   R1,>0600	   		* Column 6, i.e joystick #1
	   LDCR R1,3		   		* Select it
	   LI   R12,>0006			* Base CRU address for joystick 1
	   TB	0
	   JNE	MVDMOC				* Finish demo if fire pressed
	   TB	4
	   JNE	MVDMOC				* Finish demo if up pressed
*	   Move straight ahead
	   CLR	@DX
*	   Set sprite position (TODO: remove)
	   CLR	R0
	   MOVB	@XPOS,@R0LB
	   A	@DX,R0
	   SWPB	R0
	   MOVB	R0,@XPOS
	   MOVB	R0,@XPOS+SPROFS
MVDMO3 MOV	@TICK,R0
	   ANDI	R0,>0003			* Only permit speed changes
	   JNE	MVDMO5				* every 4 frames 
*	   Speed up
	   MOV	@SPEED,R0
	   CI	R0,MAXSPD-1
	   JGT	MVDMO5
	   INC	@SPEED
	   BL	@DSPSPD
	   JMP	MVDMO5
*	   Slow down	   
MVDMOA MOV	@SPEED,R0
	   CI	R0,1
	   JLT	MVDMO5
	   DEC	@SPEED
	   BL	@DSPSPD
	   JMP	MVDMOD
*	   Move car along path
MVDMO6 MOV	@TICK,R1			* Only move car
	   COC	@ONE,R1				* every 2nd frame
	   JEQ	MVDMOD
	   AB	*R0,@XPOS
	   AB	*R0+,@XPOS+SPROFS
	   MOVB	*R0+,R1
	   MOVB	R1,@CARPAT
	   AI	R1,>0400
	   MOVB	R1,@CARPAT+SPROFS
	   MOV	R0,@CARPTH 
*	   Slow down
	   MOV	@TICK,R0
	   ANDI	R0,>0003			* Only permit speed changes
	   JNE	MVDMO7				* every 4 frames
	   MOV	@SPEED,R0
	   CI	R0,2
	   JLT	MVDMO8
	   DECT	@SPEED
	   JMP	MVDMO9
MVDMO8 CLR	@SPEED	   
MVDMO9 BL	@DSPSPD
*	   Next path segment
MVDMO7 MOV	@CARPTH,R0
	   CB	@SPROFF,*R0
	   JNE	MVDMOD
	   CLR	@CARPTH
	   CLR	@NSHOTS
	   JMP	MVDMOD
*	   Check fire
MVDMO5 MOV	@NSHOTS,R0
	   JEQ	MVDMOD
	   CB	@SPROFF,@SASHOT+SPRATT
	   JNE	MVDMOD
*	   Fire	   
	   BL	@PLYZAP
	   MOVB	@XPOS,@SASHOT+SPRATT+1
	   LI	R0,STARTY-16*256
	   MOVB	R0,@SASHOT+SPRATT
	   DEC	@NSHOTS
	   JNE	MVDMOD
	   MOVB	@CPAT0B,@CARPAT
	   MOVB	@CPAT1B,@CARPAT+SPROFS
*	   Return	   
MVDMOD DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// MVDMO

*********************************************************************
*
* Create other cars
*
CRCARS MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@SCRLY,R0
	   ANDI	R0,>003F			* Consider creating car every 64 pixels
	   JNE	CRCRS8				* i.e. every 8 character rows
	   MOV	@SPEED,R0			* Don't create if scroll speed = 0
	   JEQ	CRCRS8
	   MOV	@DELAY,R0			* or if a delay is effective.
	   JNE	CRCRS8	  
	   BL	@RAND				* Finally add some randomness
	   MOV	@LEVEL,R1
	   SLA	R1,11				* Level * 2048
	   AI	R1,>6000
	   C	R0,R1
	   JH	CRCRS8
*	   Find an available car
	   LI	R5,CAR1Y
	   LI	R6,CAR1DY
	   LI	R7,SPRATT+SACAR1
	   LI	R2,NCARS
CRCRS1 MOV	*R5,R1
	   JNE	CRCRS7
*	   Found	
	   MOV	@SCRLY,R0			* Set y position just outside screen top 
	   AI	R0,192+16			* in map coordinates
	   MOV	R0,*R5
*	   Set x position
	   CLR	R0					* Top row
	   BL	@RDPOS				* R1 = road left position
	   MOV	R1,R2
*	   Find a random position
	   BL	@RAND
	   ANDI	R0,>003F			* Modulo 64
	   MPY	@ROADW,R0			* Multiply by road width
	   SRL	R1,6				* Divide result by 64
	   A	R2,R1				* Add road left position
	   SWPB	R1
	   MOVB	R1,@1(R7)			* Set sprite x
	   MOVB	R1,@1+SPROFS(R7)	* Set sprite x for shadow
*	   Check if we should create special item
	   MOV	@SCRLY,R0
	   ANDI	R0,>01FF			* Create fuel every 16th times
	   JEQ	CRCRS3
	   MOV	@RANDNO,R0
	   CI	R0,28000
	   JGT	CRCRS4				* Create other item
*	   Create car
	   BL	@CRCAR
	   JMP	CRCRS8				* Break out
*	   Create fuel
CRCRS3 BL	@CRFUEL
	   JMP	CRCRS8				* Break out
*	   Create gun or oil
CRCRS4 CI	R0,30000			* Otherwise let chance decide
	   JGT	CRCRS6				* Create oil
*	   Create gun
CRCRS5 BL	@CRGUN
	   JMP	CRCRS8				* Break out
*	   Create oil
CRCRS6 MOV	@LEVEL,R1			* Don't create oil until level 2
	   CI	R1,2
	   JLT	CRCRS5
	   BL	@CROIL
	   JMP	CRCRS8				* Break out	   
*	   Next car
CRCRS7 INCT	R5
	   INCT	R6
	   AI	R7,4
	   DEC	R2
	   JNE	CRCRS1
*	   Return
CRCRS8 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CRCARS
	   
*********************************************************************
*
* Create car
*
CRCAR  MOV	@SCRLSP,R0		*	   Set speed
	   CI	R0,4
	   JNE	CRCAR2
	   MOV	@RANDNO,R0
	   CI	R0,10000
	   JLT	CRCAR1
	   LI	R0,3
	   JMP	CRCAR3
CRCAR1 LI	R0,2
	   JMP	CRCAR3	   
CRCAR2 LI	R0,1	    
CRCAR3 MOV	R0,*R6
*	   Set pattern
	   MOVB	@CPAT0B,@2(R7)
	   MOVB	@CPAT1B,@2+SPROFS(R7)
*	   Set color
	   MOV	@CARCOL,R1
	   ANDI	R1,>0007
	   MOVB	@COLOR0(R1),@3(R7)
	   MOVB	@CCOL1B,@3+SPROFS(R7)
	   INC	@CARCOL
	   B	*R11
*// CRCAR
	   
*********************************************************************
*
* Create fuel
*
CRFUEL LI	R0,2
	   MOV	R0,*R6
*	   Set pattern
	   MOVB	@FPAT0B,@2(R7)
	   MOVB	@FPAT1B,@2+SPROFS(R7)
*	   Set color
	   MOVB	@FCOL0B,@3(R7)
	   MOVB	@FCOL1B,@3+SPROFS(R7)
	   B	*R11
*// CRFUEL
	   
*********************************************************************
*
* Create gun
*
CRGUN  LI	R0,2
	   MOV	R0,*R6
*	   Set pattern
	   MOVB	@GPAT0B,@2(R7)
	   MOVB	@GPAT1B,@2+SPROFS(R7)
*	   Set color
	   MOVB	@GCOL0B,@3(R7)
	   MOVB	@GCOL1B,@3+SPROFS(R7)
	   B	*R11
*// CRGUN
	   
*********************************************************************
*
* Create oil
*
CROIL  CLR	*R6					* Zero speed
*	   Set pattern
	   MOVB	@OPAT0B,@2(R7)
	   MOVB	@OPAT1B,@2+SPROFS(R7)
*	   Set color
	   MOVB	@OCOL0B,@3(R7)
	   MOVB	@OCOL1B,@3+SPROFS(R7)
	   B	*R11
	   
*********************************************************************
*
* Move other cars
*
MVCARS MOV  R11,*R10+			* Push return address onto the stack
	   LI	R5,CAR1Y
	   LI	R6,CAR1DY
	   LI	R7,SPRATT+SACAR1
	   LI	R8,CAR1PT
	   LI	R9,NCARS
MVCRS1 MOV	*R5,R1				* Get y position
	   JNE	MVCRSD				* If zero the car is not active
*	   Next car
MVCRS6 INCT	R5
	   INCT	R6
	   AI	R7,4
	   INCT R8
	   DEC	R9
	   JNE	MVCRS1
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*	   Move other car
MVCRSD S	@SCRLY,R1			* Convert to inverted screen coordinates
*	   Check for out of screen
	   JLT	MVCRS7				* Out of screen bottom
	   CI	R1,192+16
	   JGT	MVCRS5				* Out of screen top
	   LI	R0,192				* Revert y axis
	   S	R1,R0
	   SWPB	R0
	   MOVB	R0,*R7				* Set y position   
	   MOVB	R0,@SPROFS(R7)		* Set y position for shadow
*	   Move car y
	   MOV	*R6,R13				* Get speed in R13
	   JLT	MVCRS8				* Skip adding if speed < 0, i.e. exploded
	   A	R13,*R5				* Add speed to position
*	   Check for path
MVCRS8 MOV	*R8,R12
	   JNE	MVCRS2	   
*	   Move car x every time it has moved 8 pixels y
	   MOV	*R5,R1				* Get y position (map coordinates)
	   ANDI	R1,>0007			* Mod 8
	   C	R1,R13				* Compare to speed
	   JHE	MVCRS6
	   MOV	R13,R13				* Check if exploded
	   JLT	MVCRS6	   
	   SWPB	R0					* Calculate row from y
	   AI	R0,8				* Middle pixel row
	   SRL	R0,3				* Convert to character rows
	   BL	@RDDX				* Get road direction at row in R1
	   MOV	R1,R1				* Check if road direction is zero
	   JNE	MVCRS9
	   CB	@CPAT0B,@2(R7)		* Check if it's a car
	   JNE	MVCRS6
	   BL	@RAND				* Add some randomness
	   MOV	@LEVEL,R1
	   INC	R1
	   SLA	R1,11				* level * 2048
	   C	R0,R1
	   JH	MVCRS6
*	   Straight road, move car towards player car
	   MOVB	@XPOS,R1			* Get player car x position
	   SB	@1(R7),R1			* Distance from other car
	   JGT	MVCRSA				* Check sign   
	   JLT	MVCRSB
	   JMP	MVCRS6				* Don't move if centered
MVCRSA MOV	@ONE,R1
	   JMP	MVCRS9
MVCRSB SETO	R1	   
MVCRS9 MOV	*R7,R0				* Get car position
	   A	R1,R0				* Move x position
	   MOV	R0,*R7				* Set car position
	   MOV	R0,@SPROFS(R7)		* Set car position for shadow
	   JMP	MVCRS6
*	   Move car along path	   
MVCRS2 MOV	@TICK,R1			* Only move car
	   COC	@ONE,R1				* every 2nd frame
	   JEQ	MVCRS3				* else check for collision   
	   AB	*R12,@1(R7)
	   AB	*R12+,@1+SPROFS(R7)
	   MOVB	*R12+,R1
	   MOVB	R1,@2(R7)
	   AI	R1,>0400
	   MOVB	R1,@2+SPROFS(R7)
	   MOV	R12,*R8
	   CB	*R12,@SPROFF
	   JNE	MVCRS6
	   CLR	*R8					* End path
	   JMP	MVCRS6
*	   Check for collision with road side
MVCRS3 MOV	*R6,R1				* Check if speed < 0, i.e. already exploded
	   JLT	MVCRS6
	   SWPB	R0					* Calculate row
	   AI	R0,8				* Middle pixel row
	   SRL	R0,3				* Convert to character rows
	   BL	@RDPOS				* Get left side road position in R1
	   CLR	R0
	   MOVB	@1(R7),@R0LB		* Get car x position
	   S	R1,R0				* Subtract road position
	   CI	R0,-3
	   JLT	MVCRS4
	   S	@ROADW,R0
	   CI	R0,3
	   JGT	MVCRS4
	   JMP	MVCRS6
*	   Collision with road side
MVCRS4 LI	R0,CPATH7
	   MOV	R0,*R8				* Explosion path
	   SETO	*R6					* Speed = -1, i.e. exploded
	   BL	@PLYXP1				* Explosion sound
	   LI	R0,SC0100			* Add score
	   BL	@ADDSCR
	   JMP	MVCRS6
*	   Car has moved outside screen	   
MVCRS7 MOV	*R8,R12				* Check for path
	   JNE	MVCRS5				* Remove if path
	   MOV	*R6,R13				* Get speed in R13
	   JLT	MVCRS5				* Remove if exploded
	   CI	R1,-32				* Check for fully out of screen
	   JLT	MVCRS5				* Remove if fully out of screen
*	   Keep car for now
	   A	*R6,*R5				* Move y position
	   B	@MVCRS6
*	   Remove car
MVCRS5 CLR	*R5					* Clear y position
	   CLR	*R8					* Clear any path
	   MOVB @SPROFF,*R7
	   MOVB @SPROFF,@SPROFS(R7)
	   B	@MVCRS6
*// MVCARS

*********************************************************************
*
* Move shot
*
MVSHOT CB	@SPROFF,@SASHOT+SPRATT
	   JEQ	MVSHO2
	   CLR	R0
	   MOVB	@SASHOT+SPRATT,@R0LB
	   CI	R0,-16
	   JLT	MVSHO1
	   AI	R0,-4
	   MOVB	@R0LB,@SASHOT+SPRATT
	   JMP	MVSHO2
*	   Turn shot off
MVSHO1 MOV	@SPROFF,@SASHOT+SPRATT
MVSHO2 B	*R11
*// MVSHOT

*********************************************************************
*
* Consume fuel
*
CONFUL MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@TICK,R0
	   ANDI	R0,>003F
	   CI	R0,1				* Frame 1
	   JNE	CONFU2
	   MOV	@FUEL,R0
	   JNE	CONFU1
*	   Out of fuel
	   LI	R0,NOFUEL
	   MOV	R0,@STATUS
	   JMP	CONFU2
CONFU1 IF	FINFUL
	   DECT	@FUEL
	   ENDIF
	   BL	@DSPFUL
*	   Play sound if fuel is low
	   MOV	@FUEL,R0
	   CI	R0,7
	   JGT	CONFU2
	   BL	@PLYWRN				* Play warning sound
*	   Return
CONFU2 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CNFUEL 
	   
*********************************************************************
*
* Change screen row position and list pointer
*
UPDSCR 
*	   Check for row change
	   MOV	@SCRLY,R0
	   ANDI	R0,>0007			* Update row every 8 pixels
	   JNE	UPDSC2
*	   Next row
	   MOV	@RDXPTR,R0			* Update road x position
	   A	*R0,@ROADX
	   DEC	@ROWPOS				* Decrement top row position
	   JNE	UPDSC2				* Check for end of screen
*	   End of screen	   
UPDSC0 LI	R0,24   
	   MOV	R0,@ROWPOS			* Reset row position
	   MOV	@SCRPTR,R0			* Get screen pointer
	   INCT	R0					* Point to next screen
	   MOV	*R0,R1				* Check for end of map
	   CI	R1,SCR000
	   JEQ	UPDSC1
	   MOV	R0,@SCRPTR 			* Save screen list pointer 
	   INCT @RDXPTR				* Update road direction list pointer
	   JMP	UPDSC2
*	   End of level
UPDSC1 MOV	@LVLDAT,R1			* Get level data address
	   MOV	@SCRL_(R1),@SCRPTR	* Screen list pointer
	   MOV	@RDDXL_(R1),@RDXPTR	* Road direction list pointer
	   MOV	@ROADX_(R1),@ROADX	* Road x position
	   MOV	@ONE,@STATUS		* Set status to completed
UPDSC2 B	*R11
*// UPDSCR

*********************************************************************
*
* Pause key
*
PKEY   MOV  R11,*R10+			* Push return address onto the stack
*	   Read keyboard column 5
PKEY1  LI  	R1,>0500            * Test column 5
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
	   LI	R12,>000A			* P key
	   TB	0
	   JEQ	PKEY7
PKEY2  TB	0
	   JNE	PKEY2				* Wait for release
	   BL	@MTESND				* Mute sound
	   LI	R2,6
PKEY3  BL	@VSYNC				* Wait to make sure we don't
	   DEC	R2					* release straight away
	   JNE	PKEY3
PKEY4  TB	0
	   JEQ	PKEY4				* Wait for press
PKEY5  TB	0
	   JNE	PKEY5				* Wait for release
	   LI	R2,6
PKEY6  BL	@VSYNC				* Wait to make sure we don't go
	   DEC	R2					* straight back to pause
	   JNE	PKEY6
	   BL	@PLYMUS				* Restart music
PKEY7  DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// PKEY

*********************************************************************
*
* Change delay and scroll speed
*
SETSPD MOV	@SPEED,R0
	   CI	R0,MAXSPD/2
	   JLT	SETSP1
	   LI	R1,4
	   CLR	R2
	   JMP	SETSP7
SETSP1 CI	R0,MAXSPD/4
	   JLT	SETSP2
	   LI	R1,2
	   CLR	R2
	   JMP	SETSP7
SETSP2 CI	R0,MAXSPD/8
	   JLT	SETSP3
	   LI	R1,2
	   LI	R2,1
	   JMP	SETSP7
SETSP3 CI	R0,MAXSPD/16
	   JLT	SETSP4
	   LI	R1,2
	   LI	R2,2
	   JMP	SETSP7
SETSP4 CI	R0,MAXSPD/32
	   JLT	SETSP5
	   LI	R1,2
	   LI	R2,3
	   JMP	SETSP7
SETSP5 CI	R0,MAXSPD/64
	   JLT	SETSP6
	   LI	R1,2
	   LI	R2,4
	   JMP	SETSP7
SETSP6 CLR	R1
	   CLR	R2
SETSP7 C	@SCRLSP,R1
	   JEQ	SETSP8
	   MOV	@SCRLY,R0
	   ANDI	R0,>0007
	   JEQ	SETSP8
	   JMP	SETSP9
SETSP8 MOV	R1,@SCRLSP
	   MOV	R2,@DELAY
SETSP9 B	*R11	   
*// SETSPD

*********************************************************************
*
* Calculate the pixel position of the left edge of the road 
* for the given character row of the currently visible screen.
*
* R0: Character row Y
*
* On return R1 contains the pixel position of the left edge of the road 
*
* Changes R2-R4
*
RDPOS  MOV	@ROADX,R1			* X0
	   MOV	@RDXPTR,R2			* Road direction list pointer
	   LI	R3,24				* 24
	   S	@ROWPOS,R3			* 24 - ROWPOS
	   S	R0,R3				* 24 - ROWPOS - Y
	   JLT	RDPOS4				* If negative or zero
	   JEQ	RDPOS4				* the row is in the lower screen
	   MOV	*R2,R4				* DX1 (-1, 0, 1)
	   JEQ	RDPOS2				* Skip if DX1 = 0
	   JLT	RDPOS1
	   A	@ROWPOS,R1			* DX1 = 1: X0 + DX1 * ROWPOS
	   JMP	RDPOS2
RDPOS1 S	@ROWPOS,R1			* DX1 = -1: X0 + DX1 * ROWPOS
RDPOS2 MOV	@2(R2),R4			* DX2 (-1, 0, 1)
	   JEQ	RDPOS6				* Skip if DX2 = 0
	   JLT	RDPOS3
	   A	R3,R1				* DX2 = 1: X0 + DX1 * ROWPOS + DX2 * (24 - ROWPOS - Y)
	   JMP	RDPOS6
RDPOS3 S	R3,R1				* DX2 = -1: X0 + DX1 * ROWPOS + DX2 * (24 - ROWPOS - Y)
	   JMP	RDPOS6
*	   Not in upper screen
RDPOS4 A	@ROWPOS,R3			* 24 - Y
	   MOV	*R2,R4				* DX1
	   JEQ	RDPOS6
	   JLT	RDPOS5
	   A	R3,R1				* X0 + DX1 * (24 - Y) 
	   JMP	RDPOS6
RDPOS5 S	R3,R1	   
RDPOS6 B	*R11
*// RDPOS

*********************************************************************
*
* Get the direction of the road (-1, 0, 1)
* for the given character row of the currently visible screen.
*
* R0: Character row Y
*
* On return R1 contains the pixel position of the left edge of the road 
*
RDDX   MOV	@RDXPTR,R1			* Road direction list pointer
	   LI	R3,24				* 24
	   S	@ROWPOS,R3			* 24 - ROWPOS
	   S	R0,R3				* 24 - ROWPOS - Y
	   JLT	RDDX1
	   MOV	@2(R1),R1			* Get DX from top screen
	   JMP	RDDX2
RDDX1  MOV	*R1,R1	 			* Get DX from bottom screen  
RDDX2  B	*R11
*//

*********************************************************************
*
* Scroll patterns vertically into 4 frames of increasing scroll offset
* and store in VDP RAM
*
SCRLPT MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@LVLDAT,R8			* Get level data
	   MOV	@PATS_(R8),R9		* Offset to special level patterns
	   CLR	R7					* R7 is the scroll offset/frame (0,2,4,6)
SCRLP1 MOV	R7,R0				* Calculate VDP address
	   SLA	R0,10				* Multiply by >0400
	   BL	@VWAD				* Setup VDP write address
	   MOV	@TCHAR_(R8),R2		* R2 is the address in the scroll tile map
	   CLR	R6					* R6 is index of current scroll tile
SCRLP2 MOV	*R2,R3				* R3 contains indices of from/to tiles
*	   Scroll to tile
	   MOV	R7,R7				* Check for 0 offset
	   JEQ	SCRLP4				* Skip 'scroll to' tile if offset is 0
	   MOV	R3,R4				* R4 LSB is index of 'scroll to' tile
	   ANDI	R4,>00FF			* Clear MSB
	   LI	R12,PAT0			* Base address of pattern definitions
	   CI	R4,48				* Check if it's a shared pattern
	   JLT	SCRLP6
	   A	R9,R12				* Add offset to special level patterns
SCRLP6 SLA	R4,3				* Multiply by 8
	   AI	R4,8				* Add 8
	   S	R7,R4				* Minus offset
	   A	R12,R4				* Add base address of CPU RAM patterns
	   MOV	R7,R5				* Copy 'offset' bytes
SCRLP3 MOVB	*R4+,@VDPWD			* Write byte to VDP RAM
	   DEC	R5					* Decrement counter
	   JNE	SCRLP3				* Loop
*	   Scroll from tile
SCRLP4 SWPB	R3
	   MOV	R3,R4				* R4 LSB is index of 'scroll from' tile
	   ANDI	R4,>00FF			* Clear MSB
	   LI	R12,PAT0			* Base address of pattern definitions
	   CI	R4,48				* Check if it's a shared pattern
	   JLT	SCRLP7
	   A	R9,R12				* Add offset to special level patterns
SCRLP7 SLA	R4,3				* Multiply by 8
	   A	R12,R4				* Add base address of CPU RAM patterns 
	   LI	R5,8				* Copy 8 bytes
	   S	R7,R5				* Minus scroll offset
SCRLP5 MOVB	*R4+,@VDPWD			* Write byte to VDP RAM
	   DEC	R5					* Decrement counter
	   JNE	SCRLP5				* Loop
*	   Loops	   
	   INCT	R2					* Next word in scroll tile map
	   INC	R6					* Next scroll tile
	   C	@TCHNM_(R8),R6		* Check if all tiles done
	   JNE	SCRLP2				* Scroll tile loop
	   INCT	R7					* Next offset/frame
	   CI	R7,8				* Check if last frame
	   JNE	SCRLP1				* Frame loop
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// SCRLP  
	   
*********************************************************************
*
* Init status panel
*
* R0 Destination address
*
INIPNL MOV  R11,*R10+			* Push return address onto the stack
	   LI	R1,MD1
	   LI	R2,24				* 24 lines
	   LI	R3,VDPWD
	   ORI  R0,>4000			* Set the two MSbits to 01 for write
INIPN1 MOVB @R0LB,@VDPWA		* Send low byte of VDP RAM write address
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   LI	R4,1
	   BL	@VM8BW
	   AI	R0,32
	   DEC	R2
	   JNE	INIPN1
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// VMLW8

*********************************************************************
*
* Initialize sprites
*
INISPR MOV  R11,*R10+			* Push return address onto the stack
*	   Upload patterns
	   LI	R0,SPRPTB
	   LI	R1,SPRPAT
	   LI	R2,NSPRPS*32
	   BL	@VMBW
*	   Copy intial attributes
	   LI	R0,SPRATT
	   LI	R1,SPRATI
	   LI	R2,NSPRTS*4
INISP1 MOVB	*R1+,*R0+
	   DEC	R2
	   JNE	INISP1
*	   Disable sprites beyond NSPRTS
	   LI	R0,NSPRTS*4+SPRAT0
	   LI	R1,>D000
	   BL	@VSBW
	   LI	R0,NSPRTS*4+SPRAT1
	   LI	R1,>D000
	   BL	@VSBW
*	   Copy to VDP
	   BL	@CPYSPR
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// INISPR	   
	   
*********************************************************************
*
* Hide sprites
*
HIDSPR MOV  R11,*R10+			* Push return address onto the stack
	   LI	R0,SPRATT
	   LI	R1,>C000
	   LI	R2,NSPRTS
HIDSP1 MOVB	R1,*R0
	   AI	R0,4
	   DEC	R2
	   JNE	HIDSP1
	   BL	@CPYSPR
	   BL	@CHGST
	   BL	@CPYSPR
	   BL	@CHGST
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// HIDSPR

*********************************************************************
*
* Copy sprite attributes to VDP RAM double buffer
* Implements a simple flicker algorithm where we cycle between the
* quarter of the table that gets the lowest sprite numbers
*
CPYSPR MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@SPRTBL,R0			* Check which table to use
	   JEQ	CPYSP1
	   LI	R0,SPRAT1
	   JMP	CPYSP2
CPYSP1 LI	R0,SPRAT0	   
CPYSP2 BL	@VWAD				* Setup VDP write address
	   LI	R3,VDPWD
*	   Flicker routine
	   IF	FLICKR	   
	   MOV	@TICK,R4
	   ANDI	R2,>0003			* n = 0,1,2,3
	   MOV	R2,R1
	   SLA	R1,4				* Multiply by 16 to get source offset
	   AI	R1,SPRATT			* Add address of CPU RAM attributes table
	   SLA	R2,1				* n * 2 = 0,2,4,6
	   LI	R4,8
	   S	R2,R4				* Copy (8 - (n * 2)) * 8 bytes
	   JEQ	CPYSP3
	   BL	@VM8BW				* Copy first part
CPYSP3 LI	R1,SPRATT			* Copy second part from start of table
	   MOV	R2,R4				* Copy (n * 2) * 8 bytes
	   JEQ	CPYSP4
	   BL	@VM8BW				* Copy second part
*	   Copy remaining sprites (not rotated)
CPYSP4 LI	R1,SPRATT+64
	   LI	R4,NSPRTS-16/2		* Groups of 8 bytes to copy
	   BL	@VM8BW				* Copy
*	   Just copy
	   ELSE
	   LI	R1,SPRATT
	   LI	R4,NSPRTS/2
	   BL	@VM8BW				* Copy
	   ENDIF
*	   Return
CPYSP5 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CPYSPR

*********************************************************************
*
* Display speed
*
DSPSPD MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@SPEED,R1
	   MOV	R1,R2
	   SRL	R2,3				* Speed div 8: Row offset from bottom 
	   MOV	R2,R3				* Save it
	   SLA	R2,5				* Character offset  
	   ANDI R1,>0007			* Speed mod 8: Which character to use
	   MOV	R1,R4				* Save it
*	   Display partial character
	   CI	R3,MAXSPD/8			* Skip for max speed
	   JEQ	DSPSP0
	   SRL	R1,1				* Skip odd (only 4 chars)
	   AI	R1,248				* Add base char
	   SWPB	R1
	   LI	R0,21*32+25
	   S	R2,R0
	   BL	@MTRROW
*	   Display full character below
DSPSP0 CI	R4,1
	   JGT	DSPSP1
	   MOV	R3,R3
	   JEQ	DSPSP1
	   LI	R1,252*256
	   LI	R0,22*32+25
	   S	R2,R0
	   BL	@MTRROW
*	   Display space above
DSPSP1 CI	R4,6
	   JLT	DSPSP2
	   CI	R3,7
	   JEQ	DSPSP2
	   LI	R1,248*256
	   LI	R0,20*32+25
	   S	R2,R0
	   BL	@MTRROW
*	   Return
DSPSP2 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// DSPSPD

*********************************************************************
*
* Display fuel
*
DSPFUL MOV  R11,*R10+			* Push return address onto the stack
	   MOV	@FUEL,R2
	   SRL	R2,3				* Fuel div 8
	   LI	R4,21*32+29			* Screen offset
*	   Display full characters	   
	   MOV	R2,R3
	   JEQ	DSPFU2
	   LI	R1,252*256			* Character
DSPFU1 MOV	R4,R0
	   BL	@MTRROW
	   AI	R4,-32
	   DEC	R3
	   JNE	DSPFU1
*	   Display partial character
DSPFU2 MOV	@FUEL,R1
	   ANDI	R1,>0007			* Fuel mod 8
	   SRL	R1,1				* Skip odd (only 4 chars)
	   AI	R1,248				* Add base char
	   SWPB	R1
	   MOV	R4,R0
	   BL	@MTRROW
	   AI	R4,-32
*	   Display empty characters	   
	   LI	R3,7
	   S	R2,R3
	   JEQ	DSPFU4
	   JLT	DSPFU4				* Needed if fuel = 64
	   LI	R1,248*256			* Character
DSPFU3 MOV	R4,R0
	   BL	@MTRROW
	   AI	R4,-32
	   DEC	R3
	   JNE	DSPFU3
*	   Return
DSPFU4 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// DSPFUL

*********************************************************************
*
* Display one row of a meter (one character repeated twice)
* in both name table buffers
*
* R0: Screen offset
* R1: Character to write
*
MTRROW LI	R5,VDPWD
	   ORI  R0,>4000				* Set the two MSbits to 01 for write
	   AI	R0,NAMET0
	   MOVB @R0LB,@VDPWA			* Send low byte of VDP RAM write address   
	   MOVB R0,@VDPWA				* Send high byte of VDP RAM write address
	   MOVB	R1,*R5
	   MOVB	R1,*R5
	   AI	R0,NAMET1-NAMET0
	   MOVB @R0LB,@VDPWA			* Send low byte of VDP RAM write address   
	   MOVB R0,@VDPWA				* Send high byte of VDP RAM write address
	   MOVB	R1,*R5
	   MOVB	R1,*R5
	   B	*R11
*// MTRROW

*********************************************************************
*
* Display lives / cars
*
DSPLIV MOV  R11,*R10+			* Push return address onto the stack
	   LI	R0,32*12+26+NAMET0
	   BL	@VWAD
	   BL	@DSPLV0
	   AI	R0,NAMET1-NAMET0
	   BL	@VWAD
	   BL	@DSPLV0
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
DSPLV0 MOV	@LIVES,R1
	   DEC	R1
	   CI	R1,6
	   JLT  DSPLV1
	   LI	R1,5
DSPLV1 LI	R2,5 
	   S	R1,R2
	   MOV	R1,R1
	   JEQ	DSPLV3
	   JLT	DSPLV3
DSPLV2 MOVB	@CHCAR,@VDPWD
	   DEC	R1
	   JNE	DSPLV2
DSPLV3 MOV	R2,R2
	   JEQ	DSPLV5
DSPLV4 MOVB	@CHSPAC,@VDPWD
	   DEC	R2
	   JNE	DSPLV4
DSPLV5 B	*R11
*// DSPLIV

*********************************************************************
*
* Display progress indicator
*
DSPPGI MOV  R11,*R10+			* Push return address onto the stack
	   CLR	R1
	   MOV	@SCRLY,R2
	   LI	R3,MAPH
	   DIV	R3,R1				* Calculate height of progress indicator
	   SLA	R1,5				* Convert to character offset
*	   Name table 0
	   LI	R0,22*32+27+NAMET0
	   S	R1,R0
	   LI	R3,VDPWD
	   BL	@VWAD
	   MOVB	@CHPGI3,*R3
	   MOVB	@CHPGI4,*R3 
*	   Display character below PGI
	   AI	R0,32
	   BL	@VWAD
	   MOVB	@CHPGI1,*R3 
	   MOVB	@CHPGI2,*R3 
*	   Name table 1
	   AI	R0,NAMET1-NAMET0-32
	   BL	@VWAD
	   MOVB	@CHPGI3,*R3 
	   MOVB	@CHPGI4,*R3 
*	   Display character below PGI
	   AI	R0,32
	   BL	@VWAD
	   MOVB	@CHPGI1,*R3 
	   MOVB	@CHPGI2,*R3 	   
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11

*// DSPPGI

*********************************************************************
*
* Add to score
*
* R0: Address of low-endian 6 byte digit sequence to add
*
* R0-R4 are changed
*
ADDSCR MOV  R11,*R10+			* Push return address onto the stack
	   LI	R1,SCORE			* Address of score byte sequence 
   	   MOVB	@3(R1),R13			* Save thousands digit
	   LI	R2,6
	   CLR	R3
	   CLR	R4					* Carry
ADDSC1 MOVB	*R1,R3				* Read digit
	   AB	*R0+,R3				* Add digit
	   A	R4,R3				* Add old carry
	   CI	R3,>0A00			* Check for new carry
	   JLT	ADDSC2
	   LI	R4,>0100			* Set carry
	   AI	R3,->0A00		
	   JMP	ADDSC3
ADDSC2 CLR	R4					* Reset carry
ADDSC3 MOVB	R3,*R1+				* Write back   
	   DEC	R2
	   JNE	ADDSC1
*	   Display score
	   LI	R0,32*5+25			* Screen offset
	   LI	R1,SCORE
	   BL	@DSPSCR
*	   Check for extra life	
	   LI	R1,SCORE
	   CB	@3(R1),R13			* Check if thousands have changed
	   JEQ	ADDSC4
	   DEC  @XLFCNT				* Decrement extra life counter
	   JNE	ADDSC4
*	   Extra life when counter reaches zero
	   LI	R0,XLFSCO			* Reset extra life counter
	   MOV	R0,@XLFCNT
	   INC	@LIVES
	   BL	@DSPLIV
	   BL	@PLYXLF
*	   Check for, and display, high score
ADDSC4 BL	@CHKHGH
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// ADDSCR

*********************************************************************
*
* Check if score is larger than high score and display it if so
*
CHKHGH MOV  R11,*R10+			* Push return address onto the stack
	   LI	R0,SCORE+5
	   LI	R1,HSCORE+5
	   LI	R2,6
CHKHG1 CB	*R0,*R1				* Check digit
	   JGT	NEWHGH
	   JLT	CHKHGE
	   DEC	R0
	   DEC	R1
	   DEC	R2
	   JNE	CHKHG1
	   JMP	CHKHGE
NEWHGH LI	R0,SCORE			* New high score
	   LI	R1,HSCORE
	   MOV	R2,3
CHKHG2 MOV	*R0+,*R1+			* Copy score to high score
	   DEC	R2
	   JNE	CHKHG2
	   LI	R0,32*2+25
	   LI	R1,HSCORE
	   BL	@DSPSCR				* Display high score
*	   Return
CHKHGE DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// CHKHGH

*********************************************************************
*
* Display score
*
* R0: Screen offset (characters) for displayed score 
* R1: Address of score data structure
*
DSPSCR MOV  R11,*R10+			* Push return address onto the stack
	   AI	R1,5				* Begin at the end
	   LI	R4,DSPBUF			* Buffer for displayable characters
	   LI	R2,6
DSPSC1 MOVB	*R1,R3				* Copy score digit
	   AI	R3,CHZERO*256		* Add offset for zero character
	   MOVB	R3,*R4+				* Copy to display buffer
	   DEC	R1
	   DEC	R2
	   JNE	DSPSC1
*	   Display score
	   ORI  R0,>4000			* Set the two MSbits to 01 for write
	   LI	R3,VDPWD
	   LI	R1,DSPBUF
	   AI	R0,NAMET0
	   MOVB @R0LB,@VDPWA		* Send low byte of VDP RAM write address   
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   LI	R1,DSPBUF
	   AI	R0,NAMET1-NAMET0
	   MOVB @R0LB,@VDPWA		* Send low byte of VDP RAM write address   
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
*	   Return	   
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// DSPSCR

*********************************************************************
*
* Display box
*
* R0: Screen offset (characters) of upper left corner
* R1: Width	(>=3)
* R2: Height (>=3)
*
* Modifies R0-R5
*
DSPBOX MOV  R11,*R10+			* Push return address onto the stack
	   DECT	R1					* Subtract columns for left and right
	   DECT	R2					* Subtract rows for top and bottom
*	   Name table 0	
	   MOV	R0,R3
	   AI	R0,NAMET0
	   BL	@DSPBO1
*	   Name table 1
	   MOV	R3,R0
	   AI	R0,NAMET1
	   BL	@DSPBO1
*	   Return	   
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*	   Display box in a single name table
DSPBO1 MOV  R11,*R10+			* Push return address onto the stack
*	   Top row
	   BL	@VWAD				* Setup write address
	   MOVB	@CHTOPL,@VDPWD
	   MOV	R1,R4
DSPBO2 MOVB	@CHTOPM,@VDPWD
	   DEC	R4
	   JNE	DSPBO2
	   MOVB	@CHTOPR,@VDPWD
*	   Middle rows	   
	   MOV	R2,R5
DSPBO3 AI	R0,32
	   BL	@VWAD				* Setup write address
	   MOVB	@CHLEFT,@VDPWD
	   MOV	R1,R4
DSPBO4 MOVB	@CHSPAC,@VDPWD
	   DEC	R4
	   JNE	DSPBO4
	   MOVB	@CHRGHT,@VDPWD
	   DEC	R5
	   JNE	DSPBO3
*	   Bottom row	   
	   AI	R0,32
	   BL	@VWAD				* Setup write address
	   MOVB	@CHBOTL,@VDPWD
	   MOV	R1,R4
DSPBO5 MOVB	@CHBOTM,@VDPWD	   
	   DEC	R4
	   JNE	DSPBO5
	   MOVB	@CHBOTR,@VDPWD
*	   Return	   
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// DSPBOX

*********************************************************************
*
* Display ROAD HUNTER
*
DSPRH  MOV  R11,*R10+			* Push return address onto the stack
*	   Display ROAD
	   LI	R0,8*32+25
	   LI	R1,TXTROA
	   LI	R2,6
	   BL	@DSPTXT
*	   Display HUNTER
	   LI	R0,9*32+25
	   LI	R1,TXTHUN
	   LI	R2,6
	   BL	@DSPTXT
*	   Return	   
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// DSPRH

*********************************************************************
*
* Display RASMUS 2014
*
DSPRAS  MOV  R11,*R10+			* Push return address onto the stack
*	   Display RASMUS
	   LI	R0,8*32+25
	   LI	R1,TXTRAS
	   LI	R2,6
	   BL	@DSPTXT
*	   Display 2014
	   LI	R0,9*32+25
	   LI	R1,TXTYEA
	   LI	R2,6
	   BL	@DSPTXT
*	   Return	   
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// DSPRAS

*********************************************************************
*
* Copy text from CPU RAM to both screen/name table buffers
*
* R0: Screen offset (0 - 767)
* R1: Source address in CPU RAM
* R2: Number of characters to copy
*
* Modifies R0-R5
*
DSPTXT MOV  R11,*R10+			* Push return address onto the stack
	   MOV	R1,R3				* Save source address
	   MOV	R2,R4				* Save number of characters
	   AI	R0,NAMET0			* Add VDP RAM offset of first name table
	   BL	@VWAD				* Setup write address
	   BL	@DSPTX1	   
	   MOV	R3,R1				* Restore source address
	   MOV	R4,R2				* Restore number of characters
	   AI	R0,NAMET1-NAMET0	* Next name table buffer
	   BL	@VWAD				* Setup write address
	   BL	@DSPTX1
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
DSPTX1 MOVB	*R1+,R5
	   CB	@SPACE,R5			* Adjust character number of space
	   JNE	DSPTX2
	   MOVB @CHSPAC,R5
	   JMP	DSPTX3
DSPTX2 AB	@CHOFFS,R5			* Adjust character number
DSPTX3 MOVB R5,@VDPWD
	   DEC	R2
	   JNE	DSPTX1
	   B	*R11	   
*// DSPTXT

*********************************************************************
*
* Wait for up or fire
*
* R2: Number of frames to wait before giving up
*
WTKEY  MOV  R11,*R10+			* Push return address onto the stack
	   MOV	R2,R6				* Vsync counter
	   LI	R7,120				* Text toggle count down
	   SETO	R8					* Text toggle flag
*	   Read joystick
WTKEY0 LI   R12,>0024	  		* CRU address of the column decoder 
	   LI   R1,>0600	   		* Column 6, i.e joystick #1
	   LDCR R1,3		   		* Select it
	   LI   R12,>0006			* Base CRU address for joystick 1
	   TB	4					* Test up
	   JNE	WTKEY1
	   TB	0					* Also test fire
	   JNE	WTKEY1
*	   Read keyboard column 0 (Space)
	   CLR  R1                  * Test column 0
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
       LI   R12,>0006           * Address to read rows
       STCR R13,8	   
	   ANDI R13,>0200           * Mask off space bar
	   JEQ	WTKEY1
*	   Check for vsync
	   MOVB	@VDPSTA,R0
	   ANDI	R0,>8000
	   JEQ	WTKEY0
	   DEC	R7
	   JNE	WTKEY4
*	   Display text
	   LI	R7,120				* Reset counter
	   INV	R8					* Toggle flag
	   JLT	WTKEY3
	   BL	@DSPRAS
	   JMP	WTKEY4
WTKEY3 BL	@DSPRH	   
*	   Loop
WTKEY4 DEC	R6
	   JNE	WTKEY0
	   BL	@DSPRH
	   CLR	R0					* Signal no press
	   JMP	WTKEY2
WTKEY1 BL	@DSPRH
	   SETO	R0					* Signal press
*	   Return	   
WTKEY2 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11	   
*// WTKEY

*********************************************************************
*
* Generate a pseudo random number
*
* On return R0 contains the number, which is also stored at @RANDNO
*
* R14 and R15 are modified
*
RAND   LI	R14,28643			* A prime number to multiply by
	   MPY	@RANDNO,R14			* Multiply by last random number
	   AI	R15,31873			* Add a prime number
	   MOV	@TICK,R0			* Use the VSYNC tick to mix it up a little
*	   ANDI	R0,>000F			* Check if shift count is 0
*	   JEQ	RAND1				* A 0 count means shift 16, which is a wash
	   SRC	R15,0				* Mix up the number to break odd/even pattern
RAND1  MOV	R15,@RANDNO			* Save this number for next time
	   MOV	R15,R0
	   B	*R11
*// RAND

*********************************************************************
*
* Set graphics mode
*
GMODE  MOV  R11,*R10+			* Push return address onto the stack
	   LI	R0,>0000			* Reg 0: Graphics 1 mode,
	   BL   @VWTR				* external video off.
	   LI   R0,>01C2			* Reg 1: 16K, display on, no interrupt,
	   BL   @VWTR				* size = 1, mag = 0.
	   LI   R0,>0208			* Reg 2: Screen Image (Name) Table 
	   BL   @VWTR				* NAMET0 = >2000 (>08 x >400), >300 bytes
	   LI   R0,>038C			* Reg 3: Color Table
	   BL   @VWTR				* COLRTB = >2300 (>8C x >40), >20 bytes
	   LI   R0,>0400			* Reg 4: Pattern Table
	   BL   @VWTR				* PTRNT0 = >0000, >0800 bytes			
	   LI   R0,>054E			* Reg 5: Sprite Attribute Table
	   BL   @VWTR				* SPRATB = >2700 (>4E * >80)
	   LI   R0,>0605			* Reg 6: Sprite Pattern Table
	   BL   @VWTR				* SPRPTB = >2800 (>05 * >800)
	   LI   R0,>0700			* Reg 7: text-mode color and backdrop color
	   BL   @VWTR				* Black border
*	   Clear VDP RAM
	   CLR	R0
	   CLR	R1
	   LI	R2,>3000
	   BL	@VSMW
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// GMODE
   
*********************************************************************
*
* VDP Multiple Lines Write
*
* R0   VDP write address
* R1   Starting read address in CPU RAM
* R2   Number of lines (of 24 bytes) to send to the VDP RAM
*
* R0 is next write address, R1 address of last byte read, R2 is 0, R3 is modified, R4 is 0
*
VMLW   MOV  R11,*R10+			* Push return address onto the stack
	   LI	R3,VDPWD
	   ORI  R0,>4000			* Set the two MSbits to 01 for write
VMLW1  MOVB @R0LB,@VDPWA		* Send low byte of VDP RAM write address
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   LI	R4,3	   			* 4 loops per line
	   BL	@VM8BW
	   AI	R0,32
	   DEC	R2
	   JNE	VMLW1
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// VMLW

*********************************************************************
*
* Write sequences of 8 bytes to the address pointed to by R3
* Copied to scratch pad as VM8BW
*
* R1   Source adddress
* R3   Destination address (VDPWD)
* R4   Number of sequences to write
*
VM8BW8 MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   MOVB *R1+,*R3			* Write byte to VDP RAM
	   DEC	R4
	   JNE	VM8BW8
	   B	*R11
VM8BWE	   
*// WM8BW

*********************************************************************
*
* VDP Set Write Address
*
* R0   Address to set VDP address counter to
*
VWAD   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte of VDP RAM write address
	   SWPB	R0
	   ORI  R0,>4000			* Set the two MSbits to 01 for write
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   ANDI R0,>3FFF			* Restore R0 top two MSbits
	   B	*R11
*// VWAD

*********************************************************************
*
* VDP Single Byte Write
*
* R0   Write address in VDP RAM
* R1   MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
VSBW   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte of VDP RAM write address
	   SWPB	R0
	   ORI  R0,>4000			* Set read/write bits 14 and 15 to write (01)
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   MOVB R1,@VDPWD			* Write byte to VDP RAM
	   B	*R11
*// VSBW

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* R0   Starting write address in VDP RAM
* R1   MSB of R1 sent to VDP RAM
* R2   Number of times to write the MSB byte of R1 to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
VSMW   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte of VDP RAM write address
	   SWPB	R0
	   ORI  R0,>4000			* Set read/write bits 14 and 15 to write (01)
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
VSMWLP MOVB R1,@VDPWD			* Write byte to VDP RAM
	   DEC  R2					* Byte counter
	   JNE  VSMWLP				* Check if done
	   B	*R11
*// VSMW

*********************************************************************
*
* VDP Multiple Byte Write
*
* R0   Starting write address in VDP RAM
* R1   Starting read address in CPU RAM
* R2   Number of bytes to send to the VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
VMBW   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte of VDP RAM write address
	   SWPB	R0
	   ORI  R0,>4000			* Set read/write bits 14 and 15 to write (01)
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
VMBWLP MOVB *R1+,@VDPWD			* Write byte to VDP RAM
	   DEC  R2					* Byte counter
	   JNE  VMBWLP				* Check if done
	   B	*R11
*// VMBW

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
VSBR   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte of VDP RAM write address
	   SWPB	R0
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
	   MOVB @VDPRD,R1			* Read byte from VDP RAM
	   B	*R11
*// VSBR

*********************************************************************
*
* VDP Multiple Byte Read
*
* R0   Starting read address in VDP RAM
* R1   Starting write address in CPU RAM
* R2   Number of bytes to read from VDP RAM
*
VMBR   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte of VDP RAM write address
	   SWPB	R0
	   MOVB R0,@VDPWA			* Send high byte of VDP RAM write address
VMBRLP MOVB @VDPRD,*R1+			* Read byte from VDP RAM
	   DEC  R2					* Byte counter
	   JNE  VMBRLP				* Check if finished
	   B	*R11
*// VMBR

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB	VDP register to write to
* R0 LSB	Value to write
*
VWTR   SWPB	R0
	   MOVB R0,@VDPWA			* Send low byte (value) to write to VDP register
	   SWPB	R0
	   ORI  R0,>8000			* Set up a VDP register write operation (10)
	   MOVB R0,@VDPWA			* Send high byte (address) of VDP register
	   B	*R11
*// VWTR	   

*********************************************************************
*
* Play music, channel 1 and 2 + drums 4
* 
PLYMUS MOV  R11,*R10+			* Push return address onto the stack
	   LI	R0,SNDTRB
	   LI	R1,1
	   BL	@PLYSND
	   LI	R0,SNDBAS
	   LI	R1,2
	   BL	@PLYSND
	   LI	R0,SNDDRM
	   LI	R1,4
	   BL	@PLYSND
*	   Return
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*// PLYMUS

*********************************************************************
*
* Play zap sound, channel 0
* 
PLYZAP LI	R0,SNDZAP
	   LI	R1,0
	   JMP	PLYSND
*// PLYZAP

*********************************************************************
*
* Play zzz sound, channel 0
* 
PLYZZZ LI	R0,SNDZZZ
	   LI	R1,0
	   JMP	PLYSND
*// PLYZZZ

*********************************************************************
*
* Play bing sound, channel 0
* 
PLYBNG LI	R0,SNDBNG
	   LI	R1,0
	   JMP	PLYSND
*// PLYBNG

*********************************************************************
*
* Play extra life sound, channel 0
* 
PLYXLF LI	R0,SNDXLF
	   LI	R1,0
	   JMP	PLYSND
*// PLYXLF

*********************************************************************
*
* Play bonus sound, channel 0
* 
PLYBON LI	R0,SNDBON
	   LI	R1,0
	   JMP	PLYSND
*// PLYBON

*********************************************************************
*
* Play warning sound, channel 0
* 
PLYWRN LI	R0,SNDWRN
	   LI	R1,0
	   JMP	PLYSND
*// PLYWRN

*********************************************************************
*
* Play boing sound, channel 0
* 
PLYBOI LI	R0,SNDBOI
	   LI	R1,0
	   JMP	PLYSND
*// PLYBOI

*********************************************************************
*
* Play explosion sound 1, channel 3
* 
PLYXP1 LI	R0,SNDXP1
	   LI	R1,3
	   JMP	PLYSND
*// PLYXP1

*********************************************************************
*
* Play explosion sound 2, channel 3
* 
PLYXP2 LI	R0,SNDXP2
	   LI	R1,3
	   JMP	PLYSND
*// PLYXP2

*********************************************************************
*
* Play sound
* 
* R0:	Address of sound data to play
* R1:	Channel to use (0-3)
*
PLYSND SLA	R1,1
	   MOV	R0,@SNDAD0(R1)
	   MOV	@ONE,@SNDCT0(R1)
	   B	*R11
*// PLYSND

*********************************************************************
*
* Mute sound
* 
MTESND MOV  R11,*R10+			* Push return address onto the stack
	   CLR	@SNDAD0				* Sound address channel 0
	   CLR	@SNDAD1				* Sound address channel 1
	   CLR	@SNDAD2				* Sound address channel 2
	   CLR	@SNDAD3				* Sound address channel 3
	   CLR	@SNDAD4				* Sound address channel 4
	   CLR	@SNDRP0				* Repeat counters
	   CLR	@SNDRP1
	   CLR	@SNDRP2
	   CLR	@SNDRP3
	   CLR	@SNDRP4
	   LI	R0,MUTETB		    * Mute all
	   MOVB	*R0+,@SOUND
	   MOVB	*R0+,@SOUND
	   MOVB	*R0+,@SOUND
	   MOVB	*R0+,@SOUND
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
MUTETB BYTE	>9F,>BF,>DF,>FF
*//MTESND

*********************************************************************
*
* Sound player
* 
* Modifies R0-R3
*
SNDPLR LI	R2,8				* R2 is the channel offset
SNDPL0 MOV	@SNDAD0(R2),R0		* R0 is the source address
	   JEQ	SNDPL3				* Skip channel if zero
	   DEC	@SNDCT0(R2)			* Decrement counter
	   JGT	SNDPL3				* Skip channel if counter not zero
SNDPLB CLR	R1
	   MOVB	*R0+,R1				* Get number of bytes to read
	   JNE	SNDPL4				* If zero it's a repeat, otherwise call or normal
*	   Repeat command found
	   MOVB	*R0+,R3				* Get loop address MSB
	   MOVB	*R0+,@R3LB			* Get loop address LSB
	   MOV	@SNDRP0(R2),R1		* Get repeat counter
	   JNE	SNDPL6				* Check for repeat in progress
*	   New repeat	   
	   MOVB	*R0,R1				* Get 'number of repeats' byte
	   CI	R1,>FF00			* If repeat counter is >FF it's an infinite repeat
	   JEQ	SNDPL8				* Then don't record it
	   MOVB	R1,@SNDRP0+1(R2)	* Set repeat counter
SNDPL8 MOV	R3,@SNDAD0(R2)		* Set player address to loop address
	   JMP	SNDPL0
*	   Repeat in progress	   
SNDPL6 DEC	@SNDRP0(R2)			* Decrement repeat counter
	   JEQ	SNDPL7				* Check if last repetition
	   MOV	R3,@SNDAD0(R2)		* Set player address to loop address
	   JMP	SNDPL0
*	   Repeat done	   
SNDPL7 INC	R0					* Skip 'number of repeats' byte
	   MOV	R0,@SNDAD0(R2)
	   JMP	SNDPL0
SNDPL4 JGT	SNDPL5				* If positive it's normal sound bytes	   
*	   Call or return found
	   CI	R1,>FF00			* Check if it's a call
	   JNE	SNDPLA
*	   Call found	   
	   MOVB	*R0+,R3				* Get call address MSB
	   MOVB	*R0+,@R3LB			* Get call address LSB
	   MOV	R3,@SNDAD0(R2)		* Set player address to call address
	   MOV	R0,@SNDRA0(R2)		* Set return address
	   JMP	SNDPL0				* Next command
*	   Return found
SNDPLA MOV	@SNDRA0(R2),@SNDAD0(R2)	* Set player address to return address
	   JMP	SNDPL0				* Next command	   
*	   Play sound
SNDPL5 SWPB	R1
*	   *** Special code to stop drums during explosions (channel 3)
	   CI	R2,8				* Check for channel 4 (drums)
	   JNE	SNDPL1				* If not, move on to play sound
	   MOV	@SNDAD3,R3			* Check if channel 3 is active
	   JEQ	SNDPL1				* If not, move on to play sound
*	   Skip sound bytes	if channel 3 is active   
	   A	R1,R0
	   CLR	R1
	   JMP	SNDPL9
*	   *** Special code end
SNDPL1 MOVB	*R0+,@SOUND			* Play
	   DEC	R1
	   JNE	SNDPL1
SNDPL9 MOVB	*R0+,R1				* Read duration
	   JNE	SNDPL2
*	   End of sound data	   
	   CLR	@SNDAD0(R2)
	   JMP	SNDPL3
*	   More sound data
SNDPL2 SWPB	R1
	   MOV	R1,@SNDCT0(R2)
	   MOV	R0,@SNDAD0(R2)
SNDPL3 DECT	R2
	   JLT	SNDPLE
	   JMP	SNDPL0
SNDPLE B	*R11
*// SNDPLR

*********************************************************************
*
* Swap contents of PAD RAM and buffer
* Must be called from a workspace outside PAD
*
SWPPAD LI	R0,PAD
	   LI	R1,PADBUF
	   LI	R2,128
SWPPD1 MOV	*R0,R3
	   MOV	*R1,*R0+
	   MOV	R3,*R1+
	   DEC	R2
	   JNE	SWPPD1
	   B	*R11
*// SWPPAD

*********************************************************************
*
* Read map file into CPU RAM at MAP_A / MAP_B
* 
RDMAP  MOV  R11,*R10+			* Push return address onto the stack
*	   Set file name number
	   CLR	R0
	   MOV	@LEVEL,R1
	   LI	R2,NMAPS
	   DIV	R2,R0				* Wrap to available maps
	   C	@MEMMAP,R1			* Check if map is already loaded
	   JEQ	RDMAP1				* Return if it is
	   MOV	R1,@MEMMAP			* Store the number of the new map
	   IF	CART
	   MOV	R1,R12
	   SLA	R12,4
	   AI	R12,CMAP1A
	   BL	@ROMCPY
	   AI	R12,CSIZE
	   BL	@ROMCPY
	   JMP	RDMAP1
	   ELSE
	   AI	R1,49
	   SWPB	R1
	   MOVB	R1,@FILENO
*	   Setup variables and callback
	   LI	R1,MAP_A			* Destination address
	   MOV	R1,@DSTADR
	   LI	R1,108				* 108 records x 128 bytes = 13.5k
	   MOV	R1,@RECCNT
	   LI	R1,MAPCB
	   MOV	R1,@FILECB			* Setup callback from RDFILE
	   LI	R0,FNMAP
	   LI	R2,6
*	   Call the generic file reading routine
	   BL	@RDFILE
	   JMP	RDMAP3
	   ENDIF
*	   Wait 2 seconds to compensate for missing loading time
RDMAP1 LI	R2,120
RDMAP2 BL	@VSYNC				 
	   DEC	R2
	   JNE	RDMAP2
RDMAP3 DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
*	   Callback
MAPCB  MOV	R11,@RTADDR		    * Save return address. No stack!
	   LI	R0,PABBUF
	   MOV	@DSTADR,R1
	   LI	R2,128
	   BL	@VMBR				* Copy to CPU RAM
	   MOV	R1,@DSTADR
	   MOV	@RECCNT,R0			* Switch to upper memory
	   CI	R0,46				* when there are 45 records left
	   JNE	MAPCB1	
	   LI	R1,MAP_B			* Destination address
	   MOV	R1,@DSTADR	   
MAPCB1 MOV	@RTADDR,R11
	   B	*R11
*// RDMAP

***************************************************************
*
	   IF	CART
*
***************************************************************

***************************************************************
*
*	   ROM to RAM copy
*
* R12: Contains address of copy info structure
*
* Copy info structure
CBANK  EQU	0	* Bank select address
COFFS  EQU	2	* Bank offset
CLEN   EQU	4	* Total size
CDEST  EQU	6   * Destination address
CSIZE  EQU	8	* Structure size
*
*	   Single cart
*BOFFS  EQU	>2A					* Bank offset where data starts
*BOFFSL EQU	>116				* Bank offset for highest bank
*	   Scrolling trilogy cart
BOFFS  EQU	>64					* Bank offset where data starts
BOFFSL EQU	>170				* Bank offset for highest bank
*
BSIZE  EQU	>2000				* Bank size
BDATA  EQU	BSIZE-BOFFS			* Bank space for data and programs
*
ROMCPY MOV	@CBANK(R12),R3		* Bank
	   JEQ	ROMCP4				* Skip if null
	   LI	R0,>6000			* Source address
	   A	@COFFS(R12),R0		* Add offset in bank
	   MOV	@CLEN(R12),R4		* Total bytes to copy
	   LI	R2,BSIZE			* Max bytes to copy in bank
	   S	@COFFS(R12),R2		* Bank size minus offset
	   MOV	@CDEST(R12),R1		* Destination address
ROMCP1 MOV	*R3,*R3				* Select ROM bank   
ROMCP2 MOVB	*R0+,*R1+			* Copy byte to RAM
	   DEC	R4
	   JEQ	ROMCP4				* End of data?
	   DEC	R2
	   JNE	ROMCP2				* End of bank?
	   DECT	R3					* Next bank
	   LI	R2,BDATA			* Max bytes to copy in bank
	   CI	R3,>6000			* Check for highest bank
	   JEQ	ROMCP3
	   LI	R0,>6000+BOFFS		* Reset source address
	   JMP	ROMCP1
ROMCP3 LI	R0,>6000+BOFFSL		* Reset source address	   
	   JMP	ROMCP1	   
ROMCP4 B	*R11				* Return

*	   Single cart
*CMAP1A DATA >600e,>002a,>1f80,MAP_A
*CMAP1B DATA >600e,>1faa,>1680,MAP_B
*CMAP2A DATA >600c,>1654,>1f80,MAP_A
*CMAP2B DATA >600a,>15fe,>1680,MAP_B
*CMAP3A DATA >6008,>0ca8,>1f80,MAP_A
*CMAP3B DATA >6006,>0c52,>1680,MAP_B   

*	   Scrolling trilogy cart
CMAP1A DATA >6010,>1f48,>1f80,MAP_A
CMAP1B DATA >600e,>1f2c,>1680,MAP_B
CMAP2A DATA >600c,>1610,>1f80,MAP_A
CMAP2B DATA >600a,>15f4,>1680,MAP_B
CMAP3A DATA >6008,>0cd8,>1f80,MAP_A
CMAP3B DATA >6006,>0cbc,>1680,MAP_B

*// ROMCPY

***************************************************************
*
	   ELSE
*
***************************************************************

*********************************************************************
*
* Read file
* 
* R0:	Address of file name
* R2:	Length of file name
* @RECCNT contains number of records to read
* @FILECB contains address of routine to call when a record is read
*
RDFILE MOV  R11,*R10+			* Push return address onto the stack
	   MOV  R2,R1
	   AI	R1,5
	   MOV	R1,@FILENL			* Set file name length
	   LI	R1,FILENM
SETFNM MOVB	*R0+,*R1+			* Set the file name
	   DEC R2
	   JNE SETFNM
	   LI	R0,>2000			* Pad with spaces
SETFN1 CI	R1,PABDTE
	   JEQ	SETFN2
	   MOVB	R0,*R1+
	   JMP	SETFN1
*	   Change to temporary workspace
SETFN2 LWPI	TMPWS
*	   Swap back original contents of PAD RAM
	   BL	@SWPPAD
*	   Copy PAB data into VDP RAM
	   LI	R0,PAB
	   LI	R1,PABDAT
	   LI	R2,PABDTE-PABDAT
	   BL	@VMBW   
*	   Open
	   LI	R0,PAB+9			* Pointer to name length
	   MOV	R0,@>8356			* Store in >8356
	   BLWP	@DSRLNK				* Open file
	   DATA	8
*	   Check for errors
	   LI	R0,PAB+1
	   BL	@VSBR
	   ANDI	R1,>E000			* Mask off error code
	   JNE	FERROR
*	   Read
	   LI	R0,PAB
	   LI	R1,>0200			* READ op-code
	   BL	@VSBW				* Change op-code to READ
RDLOOP LI	R0,PAB+9			* Pointer to name length
	   MOV	R0,@>8356			* Store in >8356
	   BLWP	@DSRLNK				* Read record from file
	   DATA	8
	   MOV	@FILECB,R0
	   BL	*R0					* Call callback routine
	   DEC	@RECCNT
	   JNE	RDLOOP
*	   Close
	   LI	R0,PAB
	   LI	R1,>0100			* CLOSE op-code
	   BL	@VSBW				* Change op-code to READ
	   LI	R0,PAB+9			* Pointer to name length
	   MOV	R0,@>8356			* Store in >8356
	   BLWP	@DSRLNK				* Close file
	   DATA	8
*	   Swap contents of PAD RAM
RDEND  BL	@SWPPAD
*	   Restore workspace
	   LWPI	WRKSP
	   DECT R10					* Pop return address off the stack
	   MOV  *R10,R11
	   B	*R11
FERROR SRL	R1,5				* Convert error code to displayable char 
	   AI	R1,CHZERO*256
	   MOVB	R1,@TXTERR+12
*	   Display error
	   LI	R0,10*32+9			* Box
	   LI	R1,14
	   LI	R2,3
	   BL	@DSPBOX
	   LI	R0,11*32+10			* Text
	   LI	R1,TXTERR
	   LI	R2,12
	   BL	@DSPTXT
*	   Wait for quit	   	   
	   CLR  R1                  * Test column 0
       LI   R12,>0024           * Address for column selection
       LDCR R1,3                * Select column
       LI   R12,>0006           * Address to read rows
WTQUIT STCR R1,8
	   ANDI	R1,>1100
	   JNE	WTQUIT
*	   Quit
QUIT   BL	@MTESND
	   LWPI	TMPWS
	   BL	@SWPPAD
	   LWPI	>83E0
	   LIMI	2					
	   BLWP @>0000
*// RDFILE

PABDAT DATA	>000C				* Op-code 0 OPEN, Flags: Fixed, Int, Input, Seq
	   DATA PABBUF				* Data buffer address (VDP RAM)
	   DATA	>8000				* 128 bytes record length
	   DATA >0000				* Record number (not used for sequential)
FILENL DATA >0009				* File name length 
FILEDV TEXT	"DSK1."				* File device
FILENM TEXT	"          "		* File name
PABDTE
FNMAP  TEXT	"RDMAP"				* Map file name
FILENO TEXT	"1"					* Map file number

*********************************************************************
*
* All-purpose 'DSRLNK'
*
* Found at http://atariage.com/forums/topic/163692-ea-file-access/#entry2071618
*
DREGS  BSS	>20
DSRLNK DATA	DREGS,DSR1
SAVE1  DATA	>0000
SAVE2  DATA	>0000
SAVE3  DATA	>0000
SAVE4  DATA	>0000
SAVE5  DATA	>0000
NAMBUF BSS	6					* SINCE WE KNOW WERE USING "DSKn."
*
HEX20  DATA	>2020
HEXAA  DATA	>AAAA
PERIOD BYTE	'.','.'
H2000  DATA	>2000
CYC1   DATA	0
H1300  DATA	>1300
 
DSR1   MOV	*R14+,R5
       SZCB	@HEX20,R15
       MOV	@>8356,R0
       MOV	R0,R9
       AI	R9,>FFF8
       SWPB	R0
       MOVB	R0,@VDPWA
       SWPB	R0
       MOVB	R0,@VDPWA
       NOP
       MOVB	@VDPRD,R1
       MOVB	R1,R3
       SRL	R3,>8
       SETO	R4
       LI	R2,NAMBUF
DLOOP1 INC	R0
       INC	R4
       C	R4,R3
       JEQ	DJUMP1
       SWPB	R0
       MOVB	R0,@VDPWA
       SWPB	R0
       MOVB	R0,@VDPWA
       NOP
       MOVB	@VDPRD,R1
       MOVB	R1,*R2+
       CB	R1,@PERIOD
       JNE	DLOOP1
DJUMP1 MOV	R4,R4
       JEQ	DJUMP6
       CI	R4,>0007
       JGT	DJUMP6
       CLR	@>83D0
       MOV	R4,@>8354
       MOV	R4,@SAVE3
       INC	R4
       A	R4,@>8356
       MOV	@>8356,@SAVE4
SROM   LWPI	>83E0
       CLR	R1
       MOV	@H2000,@CYC1
       LI	R12,>1100
       JMP	DLOOP2
SROM1  LI	R12,>0F00
       MOV	@H1300,@CYC1
DLOOP2 MOV	R12,R12
       JEQ	DJUMP2
       SBZ	>00
DJUMP2 AI	R12,>0100
       CLR	@>83D0
       CI	R12,>2000
       JEQ	SROM1
       C	R12,@CYC1
       JEQ	DJUMP5
       MOV	R12,@>83D0
       SBO	>00
       LI	R2,>4000
       CB	*R2,@HEXAA
       JNE	DLOOP2
       A	@5*2+DREGS,R2
       JMP	DJUMP3
DLOOP3 MOV	@>83D2,R2
       SBO	>00
DJUMP3 MOV	*R2,R2
       JEQ	DLOOP2
       MOV	R2,@>83D2
       INCT	R2
       MOV	*R2+,R9
       MOVB	@>8355,R5
       JEQ	DJUMP4
       CB	R5,*R2+
       JNE	DLOOP3
       SRL	R5,>8
       LI	R6,NAMBUF
DLOOP4 CB	*R6+,*R2+
       JNE	DLOOP3
       DEC	R5
       JNE	DLOOP4
DJUMP4 INC	R1
       MOV	R1,@SAVE5
       MOV	R9,@SAVE2
       MOV	R12,@SAVE1
       BL	*R9
       JMP	DLOOP3
       SBZ	>00
       LWPI	DREGS
       MOV	R9,R0
       SWPB	R0
       MOVB	R0,@VDPWA
       SWPB	R0
       MOVB	R0,@VDPWA
       NOP
       MOVB	@VDPRD,R1
       SRL	R1,>D
       JNE	DJUMP7
       RTWP
DJUMP5 LWPI	DREGS
DJUMP6 CLR	R1
DJUMP7 SWPB	R1
       MOVB	R1,*R13
       SOCB	@HEX20,R15
       RTWP
*// DSRLNK

*********************************************************************
*
* Boot tracking
*
* Code copied more or less verbatim from:
* 1.7. The Art Of Assembly  Part 7. Why A Duck?
* By Bruce Harrison 1991
*
* THE SECTION HERE AT LABEL OPEN PERFORMS "BOOT TRACKING"
* THAT IS, IT TELLS OUR PROGRAM WHICH DRIVE IT WAS LOADED FROM
*
BOOTTR MOV	@>83D0,R12			* GET THE CRU BASE IN R12
	   MOV	@>83D2,R9			* GET THE ROM ADDRESS FOR DEVICE
	   SBO	0					* ENABLE THE ROM
	   AI	R9,4				* ADDING FOUR PUTS US AT THE LENGTH BYTE
	   MOVB	*R9+,R4				* PLACE THAT IN R4 AND INCREMENT R9
	   SRL	R4,8				* RIGHT JUSTIFY LENGTH IN R4
	   LI	R10,FILEDV			* POINT TO TEXT BUFFER
MOVIT  MOVB	*R9+,*R10+			* MOV ONE BYTE FROM ROM TO TEXT BUFFER
	   DEC	R4					* FINISHED?
	   JNE	MOVIT				* NO, DO ANOTHER BYTE
	   SBZ	0					* DISABLE THE ROM
	   B	*R11				* BRANCH TO NEXT SECTION OF CODE
*// BOOTTR

***************************************************************
*
	   ENDIF
*
***************************************************************

*********************************************************************
*
* Data section
*

*	   Misc variables
VDPTOP DATA >0000				* Copy of 'Highest available address of VDP RAM' from >8370
RECCNT DATA	>0000				* Record counter for disk access
DSTADR DATA	>0000				* Destination buffer address for disk access
FILECB DATA	>0000				* Address of file read callback routine
RTADDR DATA >0000				* For storing return address when stack unavailable
MEMMAP DATA -1					* The currently loaded map

*	   Sound player
SNDCT0 DATA	0			* Sound player counter channel 0
SNDCT1 DATA	0			* Sound player counter channel 1
SNDCT2 DATA	0			* Sound player counter channel 2
SNDCT3 DATA	0			* Sound player counter channel 3
SNDCT4 DATA	0			* Sound player counter channel 4
SNDRP0 DATA	0			* Sound player repeat counter channel 0
SNDRP1 DATA	0			* Sound player repeat counter channel 1
SNDRP2 DATA	0			* Sound player repeat counter channel 2
SNDRP3 DATA	0			* Sound player repeat counter channel 3
SNDRP4 DATA	0			* Sound player repeat counter channel 4
SNDRA0 DATA	0			* Sound player return address channel 0
SNDRA1 DATA	0			* Sound player return address channel 1
SNDRA2 DATA	0			* Sound player return address channel 2
SNDRA3 DATA	0			* Sound player return address channel 3
SNDRA4 DATA	0			* Sound player return address channel 4

*	   Scores
*	   Stored as low-endian 6 byte digit sequences
SCORE  BYTE 0,0,0,0,0,0			* Score current player
HSCORE BYTE 0,0,0,5,0,0			* High score
DSPBUF BSS	6					* Display buffer
SC0000 BYTE 0,0,0,0,0,0			* 0 points
SC0010 BYTE 0,1,0,0,0,0			* 10 points
SC0025 BYTE 5,2,0,0,0,0			* 25 points
SC0050 BYTE 0,5,0,0,0,0			* 50 points
SC0075 BYTE 5,7,0,0,0,0			* 75 points
SC0100 BYTE 0,0,1,0,0,0			* 100 points


SPACE  BYTE	32
CHPGI1 BYTE	203
CHPGI2 BYTE	204	   
CHPGI3 BYTE	253
CHPGI4 BYTE	254	      
CHSPAC BYTE 207
CHTOPL BYTE	240
CHTOPM BYTE	241
CHTOPR BYTE	242
CHLEFT BYTE 243
CHRGHT BYTE 244
CHBOTL BYTE 245
CHBOTM BYTE 246
CHBOTR BYTE 247
CHCAR  BYTE 255

CHOFFS BYTE	CHZERO-48

TXTLOD TEXT "LOADING"
TXTROA TEXT "=ROAD="
TXTHUN TEXT "HUNTER"
TXTRAS TEXT "RASMUS"
TXTYEA TEXT	"=2014="
TXTRDY TEXT "GET READY"
TXTDMO TEXT	"DEMO MODE"
TXTGMO TEXT "GAME OVER"
TXTOOF TEXT "OUT OF FUEL"
TXTOOC TEXT "OUT OF CARS"
TXTTRK TEXT "TRACK COMPLETED"
TXTERR TEXT	"FILE ERROR 0"

*	   Initial car y map coordinates	 
CARYI  DATA 192-STARTY
	   DATA 192-STARTY+24,192-STARTY+24
	   DATA 192-STARTY+48,192-STARTY+48
	   DATA 192-STARTY+72,192-STARTY+72
	   
*	   Car paths
CPTHDX EQU	0					* X increment
CPTHSP EQU	1					* Sprite pattern
CPTHSZ EQU	2					* Structure size
*	   Spin on the spot
CPATH0 BYTE 0,SPCR70,0,SPCR70
	   BYTE 0,SPCR60,0,SPCR60
	   BYTE 0,SPCR50,0,SPCR50
	   BYTE 0,SPCR40,1,SPCR40
	   BYTE 0,SPCR30,0,SPCR30
	   BYTE 0,SPCR20,0,SPCR20
	   BYTE 0,SPCR10,0,SPCR10
	   BYTE 0,SPCR00,1,SPCR00
	   BYTE >C0,00
*	   Tilt right
CPATH1 BYTE 4,SPCR70,2,SPCR70
	   BYTE 2,SPCR70,1,SPCR70
	   BYTE 1,SPCR70,1,SPCR00
	   BYTE 1,SPCR00,1,SPCR00
*	   BYTE 1,SPCR00,1,SPCR00
*	   BYTE 1,SPCR00,1,SPCR00
	   BYTE >C0,00
*	   Tilt left
CPATH2 BYTE -4,SPCR10,-2,SPCR10
	   BYTE -2,SPCR10,-1,SPCR10
	   BYTE -1,SPCR10,-1,SPCR00
	   BYTE -1,SPCR00,-1,SPCR00
*	   BYTE -1,SPCR00,-1,SPCR00
*	   BYTE -1,SPCR00,-1,SPCR00
	   BYTE >C0,00
*	   Full spin right
CPATH3 BYTE 4,SPCR70,2,SPCR70
	   BYTE 2,SPCR60,1,SPCR60
	   BYTE 1,SPCR50,1,SPCR50
	   BYTE 1,SPCR40,1,SPCR40
	   BYTE 1,SPCR30,1,SPCR30
	   BYTE 1,SPCR20,1,SPCR20
	   BYTE 1,SPCR10,1,SPCR10
	   BYTE 1,SPCR00,1,SPCR00
	   BYTE >C0,00
*	   Full spin left
CPATH4 BYTE -4,SPCR10,-2,SPCR10
	   BYTE -2,SPCR20,-1,SPCR20
	   BYTE -1,SPCR30,-1,SPCR30
	   BYTE -1,SPCR40,-1,SPCR40
	   BYTE -1,SPCR50,-1,SPCR50
	   BYTE -1,SPCR60,-1,SPCR60
	   BYTE -1,SPCR70,-1,SPCR70
	   BYTE -1,SPCR00,-1,SPCR00
	   BYTE >C0,00
*	   Small movement right
CPATH5 BYTE 2,SPCR00,1,SPCR00
	   BYTE 1,SPCR00,1,SPCR00
	   BYTE >C0,00
*	   Small movement left
CPATH6 BYTE -2,SPCR00,-1,SPCR00
	   BYTE -1,SPCR00,-1,SPCR00
	   BYTE >C0,00
*	   Explosion 1
CPATH7 BYTE 0,SPEX00,0,SPEX00
	   BYTE 0,SPEX00,0,SPEX00
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEM00,>C0,00
*	   Explosion 2
CPATH8 BYTE 1,SPEX00,1,SPEX00
	   BYTE 1,SPEX00,1,SPEX00
	   BYTE 0,SPEX00,0,SPEX00
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEM00,>C0,00
*	   Explosion 3
CPATH9 BYTE -1,SPEX00,-1,SPEX00
	   BYTE -1,SPEX00,-1,SPEX00
	   BYTE 0,SPEX00,0,SPEX00
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX10,0,SPEX10
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX20,0,SPEX20
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEX30,0,SPEX30
	   BYTE 0,SPEM00,>C0,00
*	   Double spin
CPATHA BYTE 1,SPCR70,1,SPCR70
	   BYTE 1,SPCR60,1,SPCR60
	   BYTE 1,SPCR50,1,SPCR50
	   BYTE 1,SPCR40,1,SPCR40
	   BYTE 0,SPCR30,0,SPCR30
	   BYTE 0,SPCR20,0,SPCR20
	   BYTE 0,SPCR10,0,SPCR10
	   BYTE 0,SPCR00,0,SPCR00
	   BYTE -1,SPCR70,-1,SPCR70
	   BYTE -1,SPCR60,-1,SPCR60
	   BYTE -1,SPCR50,0,SPCR50
	   BYTE -1,SPCR40,0,SPCR40
	   BYTE 0,SPCR30,0,SPCR30
	   BYTE 0,SPCR20,0,SPCR20
	   BYTE 0,SPCR10,1,SPCR10
	   BYTE 0,SPCR00,1,SPCR00
	   BYTE >C0,00
	   
**
*	   Sprites	   
	   
*	   Car colors
COLOR0 BYTE	>06   
COLOR1 BYTE	>02	   
COLOR2 BYTE	>07	   
COLOR3 BYTE	>08	   
COLOR4 BYTE	>0A	   
COLOR5 BYTE	>0D	   
COLOR6 BYTE	>0C	   
COLOR7 BYTE	>0F	   
	   	   
*	   Initial sprite attributes	      
SPRATI BYTE STARTY,STARTX,SPCR00,>04
	   BYTE STARTY,STARTX+40,SPCR00,>02
	   BYTE STARTY-24,STARTX,SPCR00,>07
	   BYTE STARTY-24,STARTX+40,SPCR00,>08
	   BYTE STARTY-48,STARTX,SPCR00,>0A
	   BYTE STARTY-48,STARTX+40,SPCR00,>0D
	   BYTE STARTY-72,STARTX,SPCR00,>0C
	   BYTE STARTY-72,STARTX+40,SPCR00,>0F
	   BYTE STARTY,STARTX,SPCR01,>01
	   BYTE STARTY,STARTX+40,SPCR01,>01
	   BYTE STARTY-24,STARTX,SPCR01,>01
	   BYTE STARTY-24,STARTX+40,SPCR01,>01
	   BYTE STARTY-48,STARTX,SPCR01,>01
	   BYTE STARTY-48,STARTX+40,SPCR01,>01
	   BYTE STARTY-72,STARTX,SPCR01,>01
	   BYTE STARTY-72,STARTX+40,SPCR01,>01
	   BYTE	>C0,0,SPSHOT,1
	   BYTE	>C0,0,0,0
	   BYTE	>C0,0,0,0
	   BYTE	>C0,0,0,0

*	   Initialisation of sprite patterns and colors
CPAT0B BYTE	SPCR00
CPAT1B BYTE SPCR01
CPAT0G BYTE	SPCRG0
CPAT1G BYTE SPCRG1
FPAT0B BYTE SPFUL0
FPAT1B BYTE SPFUL1	   
GPAT0B BYTE SPGUN0
GPAT1B BYTE SPGUN1	   
OPAT0B BYTE SPOIL0
OPAT1B BYTE SPOIL1	   
CCOL0B BYTE	4
CCOL1B BYTE 1
FCOL0B BYTE	4
FCOL1B BYTE	5
GCOL0B BYTE	1
GCOL1B BYTE	4
OCOL0B BYTE	1
OCOL1B BYTE	4
		
*	   Sprite patterns
SPRPAT
CAR000 DATA >070F,>1717,>171F,>1C08	* Color 6
	   DATA >030F,>1F10,>141F,>1F18
	   DATA >C0E0,>D0D0,>F0F0,>7020
	   DATA >80E0,>F030,>50D0,>F030
CAR001 DATA >0000,>0000,>0000,>0307	* Color 1
	   DATA >0C00,>0007,>0300,>0007
	   DATA >0010,>2828,>0808,>8CCC
	   DATA >6C0C,>0CCC,>AC28,>08C0
CAR010 DATA >1F3B,>7D7E,>7F5E,>6C38	* Color 6
	   DATA >190B,>0303,>0301,>0000
	   DATA >0080,>C0C0,>6000,>78FC
	   DATA >E6CA,>9E3C,>F870,>C000
CAR011 DATA >0000,>0000,>0021,>1307	* Color 1
	   DATA >0604,>0400,>0000,>0000
	   DATA >C060,>3038,>1CFC,>8603
	   DATA >1131,>61C2,>0488,>3060
CAR020 DATA >0000,>0000,>3E4F,>FEFC	* Color 6
	   DATA >FCFC,>FE47,>3E00,>0000
	   DATA >0000,>0000,>3F73,>6EE6
	   DATA >E6E6,>6E67,>3F00,>0000
CAR021 DATA >0000,>0000,>0030,>0103	* Color 1
	   DATA >0303,>0100,>000F,>0100
	   DATA >0000,>0000,>008C,>9119
	   DATA >1919,>9180,>00FF,>FC00
CAR030 DATA >0001,>0303,>0B3B,>71E8	* Color 6
	   DATA >DCBE,>FFFD,>7B3E,>0000
	   DATA >E0B0,>783C,>9CCE,>EAFC
	   DATA >7800,>C080,>0000,>0000
CAR031 DATA >0000,>0000,>0404,>0607	* Color 1
	   DATA >0301,>0002,>0401,>0F00
	   DATA >1008,>04C2,>6331,>1503
	   DATA >86EC,>1C78,>C080,>0000
CAR040 DATA >0C0F,>0B0A,>0C0F,>0701	* Color 6
	   DATA >040E,>0F0F,>0B0B,>0703
	   DATA >18F8,>F828,>08F8,>F0C0
	   DATA >1038,>F8E8,>E8E8,>F0E0
CAR041 DATA >0300,>0405,>0300,>0006	* Color 1
	   DATA >0301,>0000,>0404,>0000
	   DATA >E004,>04C6,>E606,>0636
	   DATA >E6C4,>0404,>0404,>0800
CAR050 DATA >030E,>1F3C,>7953,>673F	* Color 6
	   DATA >1E00,>0603,>0301,>0000
	   DATA >0080,>C0C0,>C0D0,>981C
	   DATA >367A,>FE7E,>BEDC,>F800
CAR051 DATA >0C11,>2043,>060C,>0800	* Color 1
	   DATA >0107,>0000,>0000,>0000
	   DATA >C060,>381C,>2C2C,>66E3
	   DATA >C985,>0101,>0102,>0438
CAR060 DATA >0000,>00FC,>E676,>6767	* Color 6
	   DATA >6776,>CEFC,>0000,>0000
	   DATA >0000,>007C,>E27F,>3F3F
	   DATA >3F7F,>F27C,>0000,>0000
CAR061 DATA >0000,>0000,>0189,>9898	* Color 1
	   DATA >9889,>3100,>3F03,>0000
	   DATA >0000,>0002,>0180,>C0C0
	   DATA >C080,>0D02,>FCF0,>0000
CAR070 DATA >0000,>0103,>0700,>3C7E	* Color 6
	   DATA >AFE7,>7379,>3D1B,>0E00
	   DATA >00F8,>BC7E,>FEFA,>762E
	   DATA >1CB8,>A080,>8000,>0000
CAR071 DATA >0000,>0000,>000F,>0301	* Color 1
	   DATA >5018,>8C86,>4020,>110F
	   DATA >0000,>4080,>0101,>81C1
	   DATA >C346,>5C70,>70E0,>C000
CAR080 DATA >060E,>1416,>1C1E,>1D09	* Color 6
	   DATA >080D,>1F10,>141F,>1F18
	   DATA >4060,>3070,>3070,>3000
	   DATA >00A0,>F030,>50D0,>F030
CAR081 DATA >0101,>0301,>0301,>0206	* Color 1
	   DATA >0702,>0007,>0300,>0007
	   DATA >8090,>C888,>C888,>CCEC
	   DATA >EC4C,>0CCC,>AC28,>08C0
EXPL00 DATA >0004,>0227,>0894,>311C	* Color 6
	   DATA >2244,>0841,>0608,>3240
	   DATA >8284,>D854,>2802,>244F
	   DATA >1410,>9DC8,>C4D6,>4241
EXPL01 DATA >0040,>3118,>560B,>8603	* Color 1
	   DATA >1D33,>0226,>0814,>0800
	   DATA >0052,>04A0,>D1F4,>D8B0
	   DATA >E8ED,>6030,>1808,>0402
EXPL10 DATA >0018,>3000,>4604,>C381	* Color 6
	   DATA >040E,>0642,>C860,>0703
	   DATA >401A,>0C44,>0060,>3103
	   DATA >A01A,>B011,>440C,>9A00
EXPL11 DATA >0002,>0902,>2813,>0C12	* Color 1
	   DATA >4A10,>2904,>2002,>1000
	   DATA >0080,>10AA,>D400,>C46C
	   DATA >44E0,>04C4,>0890,>2000
EXPL20 DATA >0010,>2000,>4200,>4081	* Color 6
	   DATA >0402,>0442,>0840,>0401
	   DATA >4008,>0400,>0060,>0102
	   DATA >A01A,>A011,>4004,>9200
EXPL21 DATA >0002,>0902,>2811,>0C12	* Color 1
	   DATA >4810,>2904,>2002,>1000
	   DATA >0080,>10AA,>5400,>8468
	   DATA >0440,>04C4,>0890,>2000
EXPL30 DATA >0000,>0000,>0204,>4100	* Color 6
	   DATA >0402,>0002,>0800,>0002
	   DATA >4000,>0400,>0020,>1002
	   DATA >A012,>2011,>0400,>0000
EXPL31 DATA >0002,>0902,>2000,>0012	* Color 1
	   DATA >4000,>0900,>0002,>0000
	   DATA >0000,>108A,>1000,>4400
	   DATA >0440,>0040,>0090,>0000
FUEL0  DATA >0000,>0000,>84BD,>8484	* Color 4
	   DATA >84AD,>94AD,>BDBD,>BD84
	   DATA >0000,>0000,>42DE,>4242
	   DATA >424A,>D64A,>DEDE,>DE42
FUEL1  DATA >0000,>0000,>4242,>7B42	* Color 5
	   DATA >7B52,>6B52,>4242,>4242
	   DATA >0000,>0000,>2121,>BD21
	   DATA >BDB5,>29B5,>2121,>2121
GUN0   DATA >0202,>0205,>0502,>0205	* Color 1
	   DATA >0502,>060D,>1D1D,>1C0C
	   DATA >C0C0,>C0E0,>E0C0,>C0E0
	   DATA >E0C0,>E0D0,>E8D0,>E890
GUN1   DATA >0101,>0102,>0201,>0102	* Color 4
	   DATA >0201,>0102,>0202,>0301
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0020,>1028,>1020
OIL0   DATA	>041E,>1F0F,>5BFB,>E7FF	* Color 1
	   DATA >3F1F,>1F3F,>6F33,>3E08
	   DATA >181E,>3E7E,>F6EC,>E8EC
	   DATA >F4FE,>FEFB,>FA66,>3C08
OIL1   DATA >0A01,>0030,>2404,>1800	* Color 4
	   DATA >4020,>2000,>104C,>0114
	   DATA >0420,>C181,>0812,>1410
	   DATA >0A00,>0100,>0180,>C214
SHOT   DATA >0000,>0000,>0101,>0100	* Color 1
	   DATA >0001,>0101,>0000,>0000
	   DATA >0000,>0000,>8080,>8000
	   DATA >0080,>8080,>0000,>0000
EMPTY  DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
	   DATA >0000,>0000,>0000,>0000
		
*	   Include sound file
	   COPY	"sound.a99"

*	   Include panel map file
	   COPY "panel.a99"

*	   Include levels file
	   COPY "levels.a99"
	   
*	   Buffer for saving PAD RAM
PADBUF BSS	256

*	   Temporary workspace for disk I/O
TMPWS  BSS	32

SLAST  EVEN
THEEND END	START